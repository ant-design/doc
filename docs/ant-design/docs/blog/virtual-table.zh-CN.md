## 问题一：为什么在 Ant Design v4 中的虚拟表格功能有限？

在 Ant Design v4 中，针对 Table 组件的自定义 `components.body` 示例实现了虚拟滚动的效果。但是很多开发者反馈该示例存在以下问题：

1. 固定列功能无法实现。
2. 合并行列功能无法实现。
3. 展开行功能无法实现。

这些功能的限制导致开发者无法满足复杂数据展示和交互需求。因此，在 Ant Design v5 中提出了一个新的解决方案。

## 问题二：Ant Design v5 中引入的 "StaticTable" 是什么？

在 Ant Design v5 中，为了提供更高性能的表格渲染和虚拟滚动支持，提出了 "StaticTable" 的概念。"StaticTable" 默认支持虚拟滚动，具有以下特点：

1. 高性能的表格渲染，适用于大量数据展示。
2. 默认支持虚拟滚动，提升表格滚动的流畅度。
3. 支持固定列、合并行列和展开行等功能。

"StaticTable" 的实现是基于底层的 `rc-table` 组件，并通过在 Ant Design 中使用 `<Table virtual />` 的方式开启该功能。

## 问题三：如何在 Ant Design v5 中使用 CSS 变量模式？

从 Ant Design v5.12.0 版本开始，重新支持了 CSS 变量模式。与 v4 版本不同的是，v5 融合了 CSS-in-JS 的能力，并将所有 Design Token 纳入了 CSS 变量的管理范畴。

通过使用 CSS 变量模式，可以实现以下功能：

1. 在同一组件中，不同主题下的样式可以共享，减少样式体积。
2. 切换主题时，无需重新序列化样式，提高主题切换性能。

如果应用依赖 Ant Design 的主题能力，建议开启 CSS 变量模式，以提升样式的可维护性和性能。

### Table 组件如何开启虚拟滚动功能？

通过设置 Table 组件的 `virtual` 属性为 true，即可开启虚拟滚动能力。此时，除了自定义的 `components.body` 外，其他 Table 功能都可以正常使用。

```tsx
<Table virtual {...otherProps} />
```

### Table 组件如何设置虚拟滚动的宽度和高度？

要设置 Table 组件虚拟滚动的宽度和高度，可以使用 `scroll` 属性。通过设置 `scroll` 的 `x` 属性来设置宽度，`y` 属性来设置高度。

```tsx
<Table virtual scroll={{ x: 2000, y: 500 }} {...otherProps} />
```

### Table 组件中除了自定义 `components.body` 外，哪些功能可以正常使用？

除了自定义的 `components.body` 外，Table 组件的其他功能都可以正常使用。可以根据实际需要配置和使用其他相关功能。

### 什么是行列组合？
行列组合是一种在表格中使用的布局方式。通过指定行合并数（Rowspan）和列合并数（Colspan），可以将多个单元格合并为一个大的单元格，从而实现复杂的表格布局。

### 行列组合的作用是什么？
行列组合的作用是使表格布局更加灵活和紧凑。通过合并多个单元格，可以将数据以更直观、更清晰的方式展示在表格中，提升用户对数据的理解和使用体验。

### 如何使用行列组合？
要使用行列组合，可以通过设置每个单元格的行合并数（Rowspan）和列合并数（Colspan）来实现。通过调整合并数，可以灵活地控制表格的布局。在实际使用中，可以根据具体的需求设置行列合并数，并结合表格组件的相关属性进行布局调整。

你可以参考[虚拟列表](/components/table#components-table-demo-virtual-list)示例来深入了解如何使用行列组合在表格中实现复杂的布局。

### antd 的 Table 组件底层使用了什么组件？
antd 的 Table 组件底层使用了 `rc-table` 组件。

### antd 的虚拟滚动功能是怎么实现的？
antd 的虚拟滚动功能是通过复用 `components` 属性实现的。中间的 `<tbody>` 被替换为 `rc-virtual-list` 组件来实现虚拟滚动。

### antd 在虚拟滚动中使用了哪个组件？
antd 在虚拟滚动中使用了 `rc-virtual-list` 组件。该组件在 antd 的各个虚拟滚动场景中都有应用，比如 Select、Tree 等。在改造中，还为 `rc-virtual-list` 添加了横向滚动的支持。

### Table 的固定列是如何实现的？

在 v4 版本中，Table 的固定列是通过 `position: sticky` 属性来实现的。这个 CSS 属性可以让元素在滚动时固定在某个位置，从而避免了在 v3 版本中需要额外渲染一份 Table 的麻烦。固定列可以实现叠加效果，只需要配置不同的偏移量即可。

### 在虚拟滚动中如何实现固定列？

在虚拟滚动中，也可以利用 `position: sticky` 属性来实现固定列的效果。只需要复用 `sticky` 样式，然后提供横向滚动就可以了。通过这种方式，`rc-virtual-list` 插件不需要关心具体的固定列实现，只需提供横向滚动功能即可。

### 固定列有哪些特点和优势？

固定列的主要特点和优势包括：

1. 在滚动过程中固定在某个位置，不会随着滚动而消失，提升了表格的可视性和易用性；
2. 可以实现叠加固定效果，通过设置不同的偏移量可以让多列同时固定；
3. 在虚拟滚动中仅需要通过复用 `sticky` 样式和提供横向滚动就可以实现固定列，简化了开发的复杂度；
4. 通过 `position: sticky` 属性实现固定列，避免了在 v3 版本中需要额外渲染一份 Table 的麻烦。

### `rc-table` 中如何使用 `useFlattenRecords`？

在 `rc-table` 中，我们可以使用 `useFlattenRecords` 将树状的 `dataSource` 打平，以支持开发者自定义的虚拟滚动能力。通过这个功能，我们可以获得一个扁平化的数据列表，方便进行数据操作和展示。这个功能是从 [@crawler-django](https://github.com/react-component/table/pull/619) 的贡献中引入的，所以我们无需重新实现打平逻辑。需要注意的是，在使用 `useFlattenRecords` 时，需要确保表格的数据源是树状结构。

### `rc-table` 可展开功能在首次和再次渲染时为什么会卡顿？

在测试 `rc-table` 的可展开功能时，我们发现了一个奇怪的现象，即表格在首次渲染和再次渲染时会有非常大的卡顿。经过断点调试，我们发现卡顿是由 `useFlattenRecords` 这个 hooks 导致的。进一步排查后发现，卡顿是由于大量的垃圾回收操作引起的。而垃圾回收操作是由一段看似不起眼的代码引发的。

具体来说，在 `useFlattenRecords` 中存在以下代码：

```tsx
// Fake code. Not used in real word
function flatten<T extends { children?: T[] }>(data: T[] = []) {
  let tmpList: T[] = [];

  for (let i = 0; i < data.length; i += 1) {
    const record = data[i];
    tmpList = [...tmpList, record, ...flatten(record.children)];
  }

  return tmpList;
}
```

在遍历过程中，尽管 `children` 为空时只会进入一次递归，但是在循环每个 Record 时都会创建一次临时的空数组。当 `dataSource` 数据量巨大时，这些临时数组会触发频繁的垃圾回收操作，导致卡顿问题的出现。

### 如何优化 `useFlattenRecords` 中的垃圾回收问题？

为了避免 `useFlattenRecords` 中不必要的垃圾回收消耗，我们可以通过改造添加逻辑来进行优化。具体操作如下：

```tsx
// Fake code. Not used in real word
function flatten<T extends { children?: T[] }>(data: T[] = [], list: T[] = []) {
  for (let i = 0; i < data.length; i += 1) {
    const record = data[i];
    list.push(record);
    flatten(record.children, list);
  }

  return list;
}
```

通过改进后的代码，在遍历过程中，我们不再创建临时的空数组，而是通过传递一个 `list` 参数进行累积。这样一来，避免了频繁创建临时数组，减少了垃圾回收操作的触发，从而提升了性能和避免了卡顿问题的发生。

### 什么是行列合并？

在Table中，行列合并是通过`rowSpan`和`colSpan`来实现的。`rowSpan`用于合并行，`colSpan`用于合并列。通过设置它们的值，可以将多个单元格合并成一个单元格，从而实现表格的行列合并效果。

### 在虚拟滚动中，为什么需要计算行列的rowSpan和colSpan？

在虚拟滚动中，由于并不是所有的节点都被渲染，可能会出现需要渲染的行列并不存在的情况。为了正确渲染这些内容，需要计算出当前屏幕区域内的所有行列的`rowSpan`和`colSpan`。这个计算过程是复杂且耗时的，需要遍历所有的行列，计算出每个行列的合并跨度。

### 如何优化虚拟滚动中的行列合并计算？

为了优化这个计算过程，可以尝试提前计算并获取`rowSpan`和`colSpan`的数据。然而，由于行列数据由`onCell`提供，而在父节点渲染时都会计算一次`onCell`，这会带来性能损耗。另外，即使计算了`rowSpan`的数据并渲染了屏幕外的行，仍然可能出现交替的`rowSpan`情况。即使全部渲染，也会导致性能问题。

### 怎样进行虚拟滚动中的行列合并裁剪？

为了解决这个问题，可以从可见区域出发，向上下获取被`rowSpan`影响的行。然后只对带有`rowSpan`的单元格进行渲染。这样可以避免不必要的渲染，提升性能。通过`extraRender`方法可以获取当前虚拟滚动中渲染的行号，并根据`onCell`方法获取每个单元格的`rowSpan`和`colSpan`信息。然后仅对受`rowSpan`影响的单元格进行渲染。这样就可以保证行列合并的正确性。

### 行列合并是否支持挤压至下层的情况？

上述实现假设了`rowSpan > 1`和`rowSpan = 0`的情况会出现。但是，并不支持将`rowSpan`用于挤压至下层的情况。不过对于数据表格而言，已经足够满足需求了。

以上是关于虚拟滚动中行列合并的一些优化方法和注意事项的介绍。

### 虚拟滚动是一个复杂的功能吗？

虚拟滚动是一个非常复杂的功能，它需要考虑的因素非常多。开发者需要权衡功能和性能，但是通过使用虚拟滚动，可以同时拥有两者的好处。

### 在实现虚拟滚动时需要注意什么？

在实现虚拟滚动时，需要注意的是通过 `components.body` 进行了虚拟滚动支持。这意味着开发者不能覆盖 `body` 部分的组件。要注意不要覆盖这部分组件，以确保虚拟滚动功能的正常运行。

### 开发者为什么需要花费精力在虚拟滚动上？

开发者需要花费精力在虚拟滚动上，因为虚拟滚动可以同时提供功能和性能的好处，让开发者不再需要在两者之间做取舍。虽然实现虚拟滚动是一个复杂的过程，但是通过权衡和努力，可以实现更好的用户体验和更高的性能。