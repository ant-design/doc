[
  {
    "title": "### 什么是 MFSU？",
    "md": "MFSU 是基于 webpack5 新特性 Module Federation 的打包提速方案。它通过分而治之的思路，将应用源代码的编译和应用依赖的编译分离。具体来说，它将变动较小的应用依赖构建为一个 Module Federation 的 remote 应用。这样一来，在应用热更新时就无需重新编译依赖，从而大幅减少热更新所需的时间。\n在 Umi 的项目中，默认开启了 MFSU 功能。如果你想关闭它，可以通过配置 `mfsu: false` 实现。\n"
  },
  {
    "title": "### MFSU 如何提升打包速度？",
    "md": "MFSU 通过将应用源代码的编译和应用依赖的编译分离，实现了打包速度的提升。具体来说，它将变动较小的应用依赖构建为一个 Module Federation 的 remote 应用。这样一来，当应用热更新时，只需要重新编译变动的部分，而无需重新编译所有的依赖。\n开启 MFSU 功能可以大幅减少热更新所需的时间，从而提高开发效率。\n"
  },
  {
    "title": "### 如何在 Umi 中开启或关闭 MFSU？",
    "md": "在 Umi 的项目中，默认开启了 MFSU 功能。如果你想关闭它，可以通过在配置文件中设置 `mfsu: false` 来实现。这样一来，在下次打包时，Umi 将不会使用 MFSU 进行模块分割和打包加速。\n开启或关闭 MFSU 可根据具体项目需求进行配置，以达到最佳的打包速度和开发体验。\n"
  },
  {
    "title": "### 什么是 normal 策略？",
    "md": "normal 策略是一种编译时分析的策略，在现代前端项目中常被使用。它通过对应用项目源码进行单独编译，并在编译的过程中收集项目本身依赖和编译引入的依赖。待项目代码编译完成后，使用收集到的结果进行项目依赖部分的代码构建。\n"
  },
  {
    "title": "### normal 策略的工作方式是什么？",
    "md": "normal 策略的工作方式可以通过以下步骤来理解：\n1. 使用配置将 normal 策略启用。\n2. 对应用项目源码进行单独编译。\n3. 在编译的过程中，收集项目本身依赖和编译引入的依赖。\n4. 待项目代码编译完成后，使用收集到的结果进行项目依赖部分的代码构建。\n5. 整个过程是串行的，即按照一定的顺序完成以上步骤。\n"
  },
  {
    "title": "### normal 策略的优势是什么？",
    "md": "normal 策略的优势在于：\n1. 通过编译时分析，可以准确地收集项目本身依赖和编译引入的依赖，确保构建过程的准确性。\n2. 串行的工作方式可以保证每个步骤按顺序完成，提高代码构建的稳定性和性能。\n"
  },
  {
    "title": "### normal 策略适用于哪些项目？",
    "md": "normal 策略适用于现代前端项目中的代码转译和构建过程。无论是 React 还是其他应用框架，都可以采用 normal 策略来进行编译时分析，以确保项目的依赖关系准确无误。\n以上就是关于 normal 策略的介绍，希望对你有帮助！\n"
  },
  {
    "title": "### 什么是 eager 策略？",
    "md": "eager 策略是一种扫描方式，用于获取项目的依赖信息。与编译时分析方式不同，eager 策略首先会读取项目中的所有源代码文件，然后通过静态分析的方式获取项目的依赖。这个过程非常快速，即使在一个庞大的项目中，只需要大约 700 毫秒的时间即可完成依赖分析。\n"
  },
  {
    "title": "### eager 策略的优缺点是什么？",
    "md": "eager 策略的优点是分析速度快，能够快速获取项目的依赖信息。它可以在项目代码编译和依赖编译之间进行并行处理，提高编译的效率。\n然而，eager 策略的缺点是由于它是一种静态分析方式，它在分析项目依赖时可能会缺失后续项目代码编译插入的依赖。因此，在使用 eager 策略时，需要注意与项目代码的依赖关系，以确保所有依赖都能正确被编译和打包。\n"
  },
  {
    "title": "### eager 策略的应用场景是什么？",
    "md": "eager 策略适合用于快速获取项目依赖信息，并进行项目代码的编译和依赖的编译。它尤其适用于大型项目，可以在较短时间内完成依赖分析和编译处理，提高开发效率。然而，需要注意在使用 eager 策略时，要确保所有依赖都能被正确处理，以避免缺失依赖导致的问题。\n"
  },
  {
    "title": "### 编译时分析的优缺点是什么？",
    "md": "编译时分析的优点是收集的依赖是完整的，项目代码和依赖代码的构建打包完全分离。当项目代码修改后，只需要构建项目代码部分，提高了构建的效率。\n缺点是构建的过程是串行的，即使部分依赖没有改变，也需要重新进行构建，导致构建时间较长。\n"
  },
  {
    "title": "### 扫描的方式的优缺点是什么？",
    "md": "扫描的方式的优点在于耗时的代码构建是并行的，对于较大项目的冷启动时间改善非常明显。这种方式可以同时构建项目代码和一部分运行时依赖，提高了构建的效率。\n缺点是有一部分运行时依赖会和项目代码一起编译，可能会增加一些不必要的构建成本。\n"
  },
  {
    "title": "### 在选择构建策略时有哪些建议？",
    "md": "* 如果不使用 Module Federation 的功能，项目依赖变动不频繁，建议先尝试 esbuild 构建。\n\n* 在 mono repo 项目中，推荐使用 \"normal\" 策略，并开启配置 \"monoreporedirect\"。\n\n* 如果项目较大，项目代码基数较大，推荐使用 \"eager\" 策略。\n\n* 如果项目刚刚启动，会频繁地改动依赖，推荐使用 \"eager\" 策略。\n\n* 对于其他类型的项目，则可以根据具体情况进行选择。\n以上是基于编译时分析和扫描方式优缺点的分析，给出的一些选择构建策略的建议。根据项目的实际情况，可以综合考虑这些因素进行选择。\n"
  },
  {
    "title": "### 如何解决依赖缺失错误？",
    "md": "当你遇到依赖缺失的错误信息时，你可以按照以下步骤来解决问题：\n1. 首先，仔细阅读错误信息，确保你确定是缺失了哪个依赖。\n\n2. 确保你的项目中已经安装了需要的依赖。可以通过运行 `npm ls` 或 `yarn list` 命令来检查你的依赖列表。\n\n3. 如果缺失的依赖确实未被安装，你可以通过运行 `npm install <package-name>` 或 `yarn add <package-name>` 命令来安装它。在命令中用实际的包名替换 `<package-name>`。\n\n4. 如果你已经安装了依赖，但仍然出现缺失错误，请确保你的依赖版本与代码中使用的版本相匹配。你可以在 `package.json` 或 `yarn.lock` 文件中查找依赖的版本信息。\n\n5. 如果你的依赖版本不匹配，你可以尝试更新依赖的版本。运行 `npm update <package-name>` 或 `yarn upgrade <package-name>` 命令来更新依赖。同样，用实际的包名替换 `<package-name>`。\n\n6. 如果以上步骤都没有解决问题，你可以尝试删除并重新安装依赖。首先运行 `npm uninstall <package-name>` 或 `yarn remove <package-name>` 命令来删除依赖，然后使用相应的命令重新安装。\n通过以上步骤，你应该能够解决依赖缺失的错误，让你的项目正常运行起来。\n"
  },
  {
    "title": "### 如何避免依赖缺失错误？",
    "md": "为了避免依赖缺失错误，你可以采取以下措施：\n1. 在开始项目之前，确保你的依赖清单（如 `package.json` 或 `yarn.lock`）是准确的、完整的，并且包含了所有需要的依赖。\n\n2. 定期检查并更新你的依赖，以确保你使用的是最新的稳定版本。你可以使用 `npm outdated` 或 `yarn outdated` 命令来检查过时的依赖。\n\n3. 在安装依赖时，可以使用精确的版本号或版本范围来指定依赖的版本。这样可以减少由于依赖升级引起的兼容性问题。\n\n4. 如果你的项目中使用了多个依赖，尽量选择与其他依赖兼容的版本。一些依赖可能会引起冲突或不兼容的情况，所以选择适当的版本可以减少问题的发生。\n通过以上措施，你可以增加项目的稳定性，减少依赖缺失错误的发生。\n"
  },
  {
    "title": "### React 多实例问题",
    "md": ""
  },
  {
    "title": "### 在浏览器中出现了什么样的报错？",
    "md": "在浏览器中报错提示了 React 多实例的问题。具体错误信息可以参考下面的截图。\n![multi-react-instance](https://gw.alipayobjects.com/mdn/rms_ffea06/afts/img/A*ScIJTZobWE4AAAAAAAAAAAAAARQnAQ)\n"
  },
  {
    "title": "### 什么是 React 多实例问题？",
    "md": "React 多实例问题指的是在某些复杂场景下，React 的代码被打包多份，导致运行时产生了多个 React 实例。这种情况可能会引起一些不可预见的错误。\n"
  },
  {
    "title": "### 如何解决 React 多实例问题？",
    "md": "可以通过使用 Module Federation 的 `shared` 配置来避免多实例的出现。在具体的配置中，可以指定某些依赖为单例，确保只有一个实例存在。例如，通过以下配置可以将 React 设置为单例：\n```ts\nmfsu: {\n  shared: {\n    react: {\n      singleton: true,\n    },\n  },\n},\n```\n"
  },
  {
    "title": "### 是否有其他依赖出现多实例的问题，可以通过类似的方式解决？",
    "md": "是的，如果存在其他依赖也出现了多实例的问题，可以使用类似的方式解决。根据具体情况，可以将相应的依赖设置为单例，避免多实例造成的问题。\n注意：如果已经开启了 MF 插件并使用了 MFSU，还需要开启 `shared` 配置。具体的操作可以参考相应的文档 [MF 插件和 MFSU 的一起使用](../max/mf#和-mfsu-一起使用)。\n"
  },
  {
    "title": "### 为什么在开启 MFSU 时，使用 script 类型的 externals 会报错？",
    "md": "在项目中，如果依赖库 a 还依赖了库 b，并且在项目的 webpack 配置中使用了 script 类型的 externals 来引入库 b，当开启 MFSU（Module Federation Shared Module）功能时，会出现报错的情况。\n根据上述代码示例中的描述，当在项目中使用 import \\* as b from 'b' 来引入库 b 时，预期会得到一个正常的 Module 信息，但实际上拿到的是一个 Promise\\<Module>。\n这个问题可以归因于 webpack 没有很好地处理 script 类型的 externals 和 module federation 之间的兼容性问题。可能是因为很少有人了解和使用 externals script 的功能，所以这个问题变得更加明显。\n"
  },
  {
    "title": "### 问题 2：如何解决 externals script 和 MFSU 之间的兼容性问题？",
    "md": "为了解决 externals script 和 MFSU 之间的兼容性问题，可以采取如下的解决方案：\n只在 `process.env.NODE_ENV === 'production'` 环境下开启 externals script 功能。\n具体实现如下：\n```ts\nexternals: {\n  ...(process.env.NODE_ENV === 'production' ? {b: ['script https://cdn/b.js', b]} : {})\n}\n```\n通过上述配置，在生产环境下会开启 externals script，而在其他环境下（如开发环境）则不使用该功能。\n为了解决 externals script 和 MFSU 之间的兼容性问题，建议将使用 externals script 的功能限定在生产环境下。\n通过在 webpack 配置中进行条件判断 `process.env.NODE_ENV === 'production'`，只有在生产环境下才添加 externals script 的配置，而在其他环境下不使用该配置。\n这样可以避免 externals script 和 MFSU 在开发环境下的冲突，确保项目的稳定性和可靠性。\n"
  },
  {
    "title": "### 什么是 externals script？",
    "md": "externals script 是 webpack 中的一个功能，用于将外部库作为脚本引入。\n在项目的 webpack 配置中，可以使用 externals 字段来配置 externals script。通过指定外部库的名称和脚本的 URL，可以将这些库作为脚本引入到项目中，而不是将其作为模块打包到项目的 bundle 中。\n这种方式适用于一些已经在全局范围内可用的库或框架，不需要再通过模块打包的方式引入。\n在问题 1 和问题 2 中提到的报错和兼容性问题，都涉及到了使用 script 类型的 externals 来引入外部库，而在开启 MFSU（Module Federation Shared Module）时出现的问题。\n因此，externals script 功能在使用时需要注意和其他功能的兼容性，特别是在开启了 MFSU 的情况下。\n问：在使用 monorepo 时，如果项目依赖了 A 包，而 A 包又依赖了项目 monorepo 中的子包 B，这种情况下应该如何配置 MFSU 的 exclude ？\n答：在这种情况下，建议使用 MFSU 的 exclude 配置来解决。具体配置如下：\n```ts\nmfsu: {\n  exclude: ['B'];\n}\n```\n这样配置可以避免项目源码依赖 A，而 A 又重新依赖项目源码，从而避免循环依赖的问题。\n"
  },
  {
    "title": "### 如何解决 worker 兼容问题？",
    "md": "如果在项目中需要在 Worker 中使用代码，需要按照以下步骤解决 Worker 兼容问题：\n1. 将 Worker 所需的依赖添加到 MFSU 的 `exclude` 配置中。可以通过修改 [`exclude` 配置](../api/config#mfsu)来实现。\n2. Worker 相关的依赖只能通过上述方式绕过，因为 Module Federation 是通过 `window` 对象来共享模块的。因此，在 Worker 中无法使用 Module Federation 中的模块。\n通过以上步骤，可以解决在项目中使用 Worker 时的兼容问题。\n"
  }
]