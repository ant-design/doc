[
  [
    {
      "title": "运行时配置",
      "properties": [
        {
          "title": "配置方式",
          "property": [],
          "md": "配置方式\n约定 \n`src/app.tsx`\n 为运行时配置。\n"
        },
        {
          "title": "TypeScript 提示",
          "property": [],
          "md": "TypeScript 提示\n如果你想在写配置时也有提示，可以通过 umi 的 defineApp 方法定义配置。\n```js\nimport { defineApp } from 'umi';\nexport default defineApp({\n  layout: () => {\n    return {\n      title: 'umi',\n    };\n  },\n});\n\n// or\nimport { RuntimeConfig } from 'umi';\nexport const layout: RuntimeConfig['layout'] = () => {\n  return {\n    title: 'umi',\n  };\n};\n```\n"
        },
        {
          "title": "配置项",
          "property": [
            {
              "title": "dva",
              "md": "dva如果你使用的 dva，那么支持配置 dva 插件的运行时配置，具体参考插件配置。比如：```tsexport default {  dva: {    immer: true,    extraModels: [],  },};```extraModelsType: string[]Default: [] 配置额外到 dva model。immerType: boolean | objectDefault: false 表示是否启用 immer 以方便修改 reducer。注：如需兼容 IE11，需配置`{ immer: { enableES5: true }}`。"
            },
            {
              "title": "数据流",
              "md": "数据流若你需要定义初始化数据，使用`getInitialState` 、`useModel` 等数据流 相关功能：你可以创建自带数据流功能的`@umijs/max` 项目，详见Umi max 简介 。或者手动开启数据流功能的插件使用该功能：```bash  pnpm add -D @umijs/plugins``````ts// .umirc.tsexport default {  plugins: [    '@umijs/plugins/dist/initial-state',    '@umijs/plugins/dist/model',  ],  initialState: {},  model: {},};```"
            },
            {
              "title": "layout",
              "md": "layout修改内置布局的配置，比如配置退出登陆、自定义导航暴露的渲染区域等。注意：需要开启layout 插件，才能使用它的运行时配置。```jsexport const layout = {  logout: () => {}, // do something};```更多具体配置参考插件文档。"
            },
            {
              "title": "onRouteChange({ routes, clientRoutes, location, action, basename, isFirst })",
              "md": "onRouteChange({ routes, clientRoutes, location, action, basename, isFirst })在初始加载和路由切换时做一些事情。比如用于做埋点统计，```tsexport function onRouteChange({  location,  clientRoutes,  routes,  action,  basename,  isFirst,}) {  bacon(location.pathname);}```比如用于设置标题，```tsimport { matchRoutes } from 'umi';export function onRouteChange({ clientRoutes, location }) {  const route = matchRoutes(clientRoutes, location.pathname)?.pop()?.route;  if (route) {    document.title = route.title || '';  }}```"
            },
            {
              "title": "patchRoutes({ routes })",
              "md": "patchRoutes({ routes })```tsexport function patchRoutes({ routes, routeComponents }) {  console.log('patchRoutes', routes, routeComponents);}````routes`: 打平的路由列表。`routeComponents`: 路由对应的组件映射。注：如需动态更新路由，建议使用`patchClientRoutes()` ，否则你可能需要同时修改`routes` 和`routeComponents`。"
            },
            {
              "title": "patchClientRoutes({ routes })",
              "md": "patchClientRoutes({ routes })修改被 react-router 渲染前的树状路由表，接收内容同useRoutes。比如在最前面添加一个`/foo` 路由，```tsximport Page from '@/extraRoutes/foo';export function patchClientRoutes({ routes }) {  routes.unshift({    path: '/foo',    element: <Page />,  });}```比如在最前面添加一个重定向路由：```tsximport { Navigate } from 'umi';export const patchClientRoutes = ({ routes }) => {  routes.unshift({    path: '/',    element: <Navigate to=\"/home\" replace />,  });};```比如添加一个嵌套路由：```tsximport Page from '@/extraRoutes/foo';export const patchClientRoutes = ({ routes }) => {  routes.push({    path: '/group',    children: [{      path: '/group/page',      element: <Page />,    }],  });};```比如和`render` 配置配合使用，请求服务端根据响应动态更新路由，```tslet extraRoutes;export function patchClientRoutes({ routes }) {  // 根据 extraRoutes 对 routes 做一些修改  patch(routes, extraRoutes);}export function render(oldRender) {  fetch('/api/routes')    .then((res) => res.json())    .then((res) => {      extraRoutes = res.routes;      oldRender();    });}```注意：直接修改 routes，不需要返回"
            },
            {
              "title": "qiankun",
              "md": "qiankunUmi 内置了`qiankun` 插件来提供微前端的能力，具体参考插件配置。"
            },
            {
              "title": "render(oldRender:",
              "md": "render(oldRender:`Function`)覆写 render。比如用于渲染之前做权限校验，```bashexport function render(oldRender) {  fetch('/api/auth').then(auth => {    if (auth.isLogin) { oldRender() }    else {      location.href = '/login';      oldRender()    }  });}```"
            },
            {
              "title": "request",
              "md": "request如果你使用了`import { request } from 'umi';` 来请求数据，那么你可以通过该配置来自定义中间件、拦截器、错误处理适配等。具体参考request 插件配置。"
            },
            {
              "title": "rootContainer(lastRootContainer, args)",
              "md": "rootContainer(lastRootContainer, args)修改交给 react-dom 渲染时的根组件。比如用于在外面包一个 Provider，```jsexport function rootContainer(container) {  return React.createElement(ThemeProvider, null, container);}```args 包含：routes，全量路由配置plugin，运行时插件机制history，history 实例"
            }
          ],
          "md": "配置项\n以下配置项按字母排序。\n"
        },
        {
          "title": "更多配置",
          "property": [],
          "md": "更多配置\nUmi 允许插件注册运行时配置，如果你使用插件，肯定会在插件里找到更多运行时的配置项。\n"
        }
      ]
    }
  ],
  [
    {
      "title": "插件 API",
      "properties": [
        {
          "title": "核心 API",
          "property": [
            {
              "title": "applyPlugins",
              "md": "applyPlugins```tsapi.applyPlugins({ key: string, type?: api.ApplyPluginsType, initialValue?: any, args?: any })```取得`register()` 注册的 hooks 执行后的数据，这是一个异步函数，因此它返回的将是一个 Promise。这个方法的例子和详解见register api"
            },
            {
              "title": "describe",
              "md": "describe```tsapi.describe({ key?:string, config?: { default , schema, onChange }, enableBy? })```在插件注册阶段( initPresets or initPlugins stage )执行，用于描述插件或者插件集的 key、配置信息和启用方式等。`key` 是配置中该插件配置的键名`config.default` 是插件配置的默认值，当用户没有在配置中配置 key 时，默认配置将生效。`config.schema` 用于声明配置的类型，基于joi 。如果你希望用户进行配置，这个是必须的 ，否则用户的配置无效`config.onChange` 是 dev 模式下，配置被修改后的处理机制。默认值为`api.ConfigChangeType.reload`，表示在 dev 模式下，配置项被修改时会重启 dev 进程。 你也可以修改为`api.ConfigChangeType.regenerateTmpFiles`, 表示只重新生成临时文件。你还可以传入一个方法，来自定义处理机制。`enableBy` 是插件的启用方式，默认是`api.EnableBy.register`，表示注册启用，即插件只要被注册就会被启用。可以更改为`api.EnableBy.config` ，表示配置启用，只有配置插件的配置项才启用插件。你还可以自定义一个返回布尔值的方法（ true 为启用 ）来决定其启用时机，这通常用来实现动态生效。e.g.```tsapi.describe({  key: 'foo',  config: {    schema(joi){      return joi.string();    },    onChange: api.ConfigChangeType.regenerateTmpFiles,  },  enableBy: api.EnableBy.config,})```这个例子中，插件的`key` 为`foo`，因此配置中的键名为`foo`，配置的类型是字符串，当配置`foo` 发生变化时，dev 只会重新生成临时文件。该插件只有在用户配置了`foo` 之后才会启用。"
            },
            {
              "title": "isPluginEnable",
              "md": "isPluginEnable```tsapi.isPluginEnable( key：string)```判断插件是否启用，传入的参数是插件的 key"
            },
            {
              "title": "register",
              "md": "register```tsapi.register({ key: string, fn, before?: string, stage?: number})```为`api.applyPlugins` 注册可供其使用的 hook。`key` 是注册的 hook 的类别名称，可以多次使用`register` 向同一个`key` 注册 hook，它们将会依次执行。这个`key` 也同样是使用`applyPlugins` 收集 hooks 数据时使用的`key`。注意：这里的 key 和 插件的 key 没有任何联系。`fn` 是 hook 的定义，可以是同步的，也可以是异步的（返回一个 Promise 即可）`stage` 用于调整执行顺序，默认为 0，设为 -1 或更少会提前执行，设为 1 或更多会后置执行。`before` 同样用于调整执行的顺序，传入的值为注册的 hook 的名称。注意：`register` 注册的 hook 的名称是所在 Umi 插件的 id。 stage 和 before 的更多用法参考tapable注意： 相较于`umi@3`，`umi@4` 去除了`pluginId` 参数。fn 的写法需要结合即将使用的 applyPlugins 的 type 参数来确定：`api.ApplyPluginsType.add``applyPlugins` 将按照 hook 顺序来将它们的返回值拼接成一个数组。此时`fn` 需要有返回值，`fn` 将获取`applyPlugins` 的参数`args` 来作为自己的参数。`applyPlugins` 的`initialValue` 必须是一个数组，它的默认值是空数组。当`key` 以`'add'` 开头且没有显式地声明`type` 时，`applyPlugins` 会默认按此类型执行。`api.ApplyPluginsType.modify``applyPlugins` 将按照 hook 顺序来依次更改`applyPlugins` 接收的`initialValue`， 因此此时`initialValue` 是必须的 。此时`fn` 需要接收一个`memo` 作为自己的第一个参数，而将会把`applyPlugins` 的参数`args` 来作为自己的第二个参数。`memo` 是前面一系列 hook 修改`initialValue` 后的结果，`fn` 需要返回修改后的`memo` 。当`key` 以`'modify'` 开头且没有显式地声明`type` 时，`applyPlugins` 会默认按此类型执行。`api.ApplyPluginsType.event``applyPlugins` 将按照 hook 顺序来依次执行。此时不用传入`initialValue` 。`fn` 不需要有返回值，并且将会把`applyPlugins` 的参数`args` 来作为自己的参数。当`key` 以`'on'` 开头且没有显式地声明`type` 时，`applyPlugins` 会默认按此类型执行。e.g.1 add 型```tsapi.register({  key: 'addFoo',  // 同步  fn: (args) => args});api.register({  key: 'addFoo',  // 异步  fn: async (args) => args * 2})api.applyPlugins({  key: 'addFoo',  // key 是 add 型，不用显式声明为 api.ApplyPluginsType.add  args: 1}).then((data)=>{  console.log(data); // [1,2]})```e.g.2 modify 型```tsapi.register({  key: 'foo',  fn: (memo, args) => ({ ...memo, a: args})})api.register({  key: 'foo',  fn: (memo) => ({...memo, b: 2})})api.applyPlugins({   key: 'foo',   type: api.ApplyPluginsType.modify,  // 必须有 initialValue  initialValue: {     a: 0,    b: 0  },  args: 1}).then((data) => {    console.log(data); // { a: 1, b: 2 }});```"
            },
            {
              "title": "registerCommand",
              "md": "registerCommand```tsapi.registerCommand({  name: string,  description? : string,  options? : string,  details? : string,  fn,  alias? : string | string[]  resolveConfigMode? : 'strict' | 'loose'})```注册命令。`alias` 为别名，比如 generate 的别名 g`fn` 的参数为`{ args }`， args 的格式同yargs 的解析结果，需要注意的是`_` 里的 command 本身被去掉了，比如执行`umi generate page foo`，`args._` 为`['page','foo']``resolveConfigMode` 参数控制执行命令时配置解析的方式，`strict` 模式下强校验 Umi 项目的配置文件内容，如果有非法内容中断命令执行；`loose` 模式下不执行配置文件的校验检查。"
            },
            {
              "title": "registerMethod",
              "md": "registerMethod```tsapi.registerMethod({ name: string, fn? })```往 api 上注册一个名为`'name'` 的方法。当传入了 fn 时，执行 fn当没有传入 fn 时，`registerMethod` 会将`name` 作为`api.register` 的`key` 并且将其柯里化后作为`fn`。这种情况下相当于注册了一个`register` 的快捷调用方式，便于注册 hook。注意：相较于`umi@3`，`umi@4` 去除了 exitsError 参数。通常不建议注册额外的方法，因为它们不会有 ts 提示，直接使用`api.register()` 是一个更安全的做法。e.g.1```tsapi.registerMethod({  name: foo,  // 有 fn  fn: (args) => {    console.log(args);  }})api.foo('hello, umi!'); // hello, umi!```该例子中，我们往api上注册了一个 foo 方法，该方法会把参数 console 到控制台。e.g.2```tsimport api from './api';api.registerMethod({  name: 'addFoo'  // 没有 fn})api.addFoo( args => args );api.addFoo( args => args * 2 );api.applyPlugins({  key: 'addFoo',  args: 1}).then((data)=>{  console.log(data); // [ 1, 2 ]});```该例子中，我们没有向`api.registerMethod` 中传入 fn。此时，我们相当于往 api 上注册了一个\"注册器\"：`addFoo`。每次调用该方法都相当于调用了`register({ key: 'addFoo', fn })`。因此当我们使用`api.applyPlugins` 的时候（由于我们的方法是 add 型的，可以不用显式声明其 type ）就可以获取刚刚注册的 hook 的值。"
            },
            {
              "title": "registerPresets",
              "md": "registerPresets```tsapi.registerPresets( presets: string[] )```注册插件集，参数为路径数组。该 api 必须在 initPresets stage 执行，即只可以在 preset 中注册其他 presetse.g.```tsapi.registerPresets([  './preset',  require.resolve('./preset_foo')])```"
            },
            {
              "title": "registerPlugins",
              "md": "registerPlugins```tsapi.registerPlugins( plugins: string[] )```注册插件，参数为路径数组。该 api 必须在 initPresets 和 initPlugins stage 执行。e.g.```tsapi.registerPlugins([  './plugin',  require.resolve('./plugin_foo')])```注意： 相较于`umi@3` ，`umi@4` 不再支持在`registerPresets` 和`registerPlugins` 中直接传入插件对象了，现在只允许传入插件的路径。"
            },
            {
              "title": "registerGenerator",
              "md": "registerGenerator注册微生成器用来快捷生成模板代码。示例：```tsimport { GeneratorType } from '@umijs/core';import { logger } from '@umijs/utils';import { join } from 'path';import { writeFileSync } from 'fs';api.registerGenerator({  key: 'editorconfig',  name: 'Create .editorconfig',  description: 'Setup editorconfig config',  type: GeneratorType.generate,  fn: () => {    const configFilePath = join(api.cwd, '.editorconfig')    if (existsSync(configFilePath)) {      logger.info(`The .editorconfig file already exists.`)      return    }    writeFileSync(      configFilePath,      `# 🎨 http://editorconfig.orgroot = true[*]indent_style = spaceindent_size = 2end_of_line = lfcharset = utf-8trim_trailing_whitespace = trueinsert_final_newline = true[*.md]trim_trailing_whitespace = false`.trimStart(),      'utf-8'    )    logger.info(`Generate .editorconfig file successful.`)  }})```更多示例见`已有生成器源码` 。"
            },
            {
              "title": "skipPlugins",
              "md": "skipPlugins```tsapi.skipPlugins( keys: string[])```声明哪些插件需要被禁用，参数为插件 key 的数组"
            }
          ],
          "md": "核心 API\nservice 和 PluginAPI 里定义的方法。\n"
        },
        {
          "title": "扩展方法",
          "property": [
            {
              "title": "addBeforeBabelPlugins",
              "md": "addBeforeBabelPlugins增加额外的 Babel 插件。传入的 fn 不需要参数，且需要返回一个 Babel 插件或插件数组。```tsapi.addBeforeBabelPlugins(() => {  // 返回一个 Babel 插件（来源于 Babel 官网的例子）  return () => {    visitor: {      Identifier(path) {        const name = path.node.name;        path.node.name = name.split(\"\").reverse().join(\"\");      }    }  }})```"
            },
            {
              "title": "addBeforeBabelPresets",
              "md": "addBeforeBabelPresets增加额外的 Babel 插件集。传入的 fn 不需要参数，且需要返回一个 Babel 插件集( presets )或插件集数组。```tsapi.addBeforeBabelPresets(() => {  // 返回一个 Babel 插件集  return () => {    return {      plugins: [\"Babel_Plugin_A\",\"Babel_Plugin_B\"]    }  }})```"
            },
            {
              "title": "addBeforeMiddlewares",
              "md": "addBeforeMiddlewares在 webpack-dev-middleware 之前添加中间件。传入的 fn 不需要参数，且需要返回一个 express 中间件或其数组。```tsapi.addBeforeMiddlewares(() => {  return (req, res, next) => {    if(false) {      res.end('end');    }    next();  }})```"
            },
            {
              "title": "addEntryCode",
              "md": "addEntryCode在入口文件的最后面添加代码（render 后）。传入的 fn 不需要参数，且需要返回一个 string 或者 string 数组。```tsapi.addEntryCode(() => `console.log('I am after render!')`);```"
            },
            {
              "title": "addEntryCodeAhead",
              "md": "addEntryCodeAhead在入口文件的最前面添加代码（render 前，import 后）。传入的 fn 不需要参数，且需要返回一个 string 或者 string 数组。```tsapi.addEntryCodeAhead(() => `console.log('I am before render!')`)```"
            },
            {
              "title": "addEntryImports",
              "md": "addEntryImports在入口文件中添加 import 语句 （import 最后面）。传入的 fn 不需要参数，其需要返回一个`{source: string, specifier?: string}` 或其数组。```tsapi.addEntryImports(() => ({  source: '/modulePath/xxx.js',  specifier: 'moduleName'}))```"
            },
            {
              "title": "addEntryImportsAhead",
              "md": "addEntryImportsAhead在入口文件中添加 import 语句 （import 最前面）。传入的 fn 不需要参数，其需要返回一个`{source: string, specifier?: string}` 或其数组。```tsapi.addEntryImportsAhead(() => ({  source: 'anyPackage'}))```"
            },
            {
              "title": "addExtraBabelPlugins",
              "md": "addExtraBabelPlugins添加额外的 Babel 插件。 传入的 fn 不需要参数，且需要返回一个 Babel 插件或插件数组。"
            },
            {
              "title": "addExtraBabelPresets",
              "md": "addExtraBabelPresets添加额外的 Babel 插件集。传入的 fn 不需要参数，且需要返回一个 Babel 插件集或其数组。"
            },
            {
              "title": "addHTMLHeadScripts",
              "md": "addHTMLHeadScripts往 HTML 的`<head>` 元素里添加 Script。传入的 fn 不需要参数，且需要返回一个 string（想要加入的代码） 或者`{ async?: boolean, charset?: string, crossOrigin?: string | null, defer?: boolean, src?: string, type?: string, content?: string }` 或者它们的数组。```tsapi.addHTMLHeadScripts(() => `console.log('I am in HTML-head')`)```"
            },
            {
              "title": "addHTMLLinks",
              "md": "addHTMLLinks往 HTML 里添加 Link 标签。 传入的 fn 不需要参数，返回的对象或其数组接口如下：```ts{    as?: string, crossOrigin: string | null,   disabled?: boolean,  href?: string,  hreflang?: string,  imageSizes?: string,  imageSrcset?: string,  integrity?: string,  media?: string,  referrerPolicy?: string,  rel?: string,  rev?: string,  target?: string,  type?: string }```"
            },
            {
              "title": "addHTMLMetas",
              "md": "addHTMLMetas往 HTML 里添加 Meta 标签。 传入的 fn 不需要参数，返回的对象或其数组接口如下：```ts{  content?: string,  'http-equiv'?: string,  name?: string,  scheme?: string  }```"
            },
            {
              "title": "addHTMLScripts",
              "md": "addHTMLScripts往 HTML 尾部添加 Script。 传入的 fn 不需要参数，返回的对象接口同addHTMLHeadScripts"
            },
            {
              "title": "addHTMLStyles",
              "md": "addHTMLStyles往 HTML 里添加 Style 标签。 传入的 fn 不需要参数，返回一个 string （style 标签里的代码）或者`{ type?: string, content?: string }`，或者它们的数组。"
            },
            {
              "title": "addLayouts",
              "md": "addLayouts添加全局 layout 组件。 传入的 fn 不需要参数，返回`{ id?: string, file: string }`"
            },
            {
              "title": "addMiddlewares",
              "md": "addMiddlewares添加中间件，在 route 中间件之后。 传入的 fn 不需要参数，返回 express 中间件。"
            },
            {
              "title": "addPolyfillImports",
              "md": "addPolyfillImports添加补丁 import，在整个应用的最前面执行。 传入的 fn 不需要参数，返回`{ source: string, specifier?:string }`"
            },
            {
              "title": "addPrepareBuildPlugins",
              "md": "addPrepareBuildPlugins"
            },
            {
              "title": "addRuntimePlugin",
              "md": "addRuntimePlugin添加运行时插件，传入的 fn 不需要参数，返回 string ，表示插件的路径。"
            },
            {
              "title": "addRuntimePluginKey",
              "md": "addRuntimePluginKey添加运行时插件的 Key， 传入的 fn 不需要参数，返回 string ，表示插件的路径。"
            },
            {
              "title": "addTmpGenerateWatcherPaths",
              "md": "addTmpGenerateWatcherPaths添加监听路径，变更时会重新生成临时文件。传入的 fn 不需要参数，返回 string，表示要监听的路径。"
            },
            {
              "title": "addOnDemandDeps",
              "md": "addOnDemandDeps添加按需安装的依赖，他们会在项目启动时检测是否安装：```ts  api.addOnDemandDeps(() => [{ name: '@swc/core', version: '^1.0.0', dev: true }])```"
            },
            {
              "title": "chainWebpack",
              "md": "chainWebpack通过webpack-chain 的方式修改 webpack 配置。传入一个fn，该 fn 不需要返回值。它将接收两个参数：`memo` 对应 webpack-chain 的 config`args:{ webpack, env }``arg.webpack` 是 webpack 实例，`args.env` 代表当前的运行环境。e.g.```tsapi.chainWebpack(( memo, { webpack, env}) => {  // set alias  memo.resolve.alias.set('a','path/to/a');  // Delete progess bar plugin  memo.plugins.delete('progess');})```"
            },
            {
              "title": "modifyAppData （",
              "md": "modifyAppData （`umi@4` 新增）修改 app 元数据。传入的 fn 接收 appData 并且返回它。```tsapi.modifyAppData((memo) => {  memo.foo = 'foo';  return memo;})```"
            },
            {
              "title": "modifyConfig",
              "md": "modifyConfig修改配置，相较于用户的配置，这份是最终传给 Umi 使用的配置。传入的 fn 接收 config 作为第一个参数，并且返回它。另外 fn 可以接收`{ paths }` 作为第二个参数。`paths` 保存了 Umi 的各个路径。```tsapi.modifyConfig((memo, { paths }) => {  memo.alias = {    ...memo.alias,    '@': paths.absSrcPath  }  return memo;})```"
            },
            {
              "title": "modifyDefaultConfig",
              "md": "modifyDefaultConfig修改默认配置。传入的 fn 接收 config 并且返回它。"
            },
            {
              "title": "modifyHTML",
              "md": "modifyHTML修改 HTML，基于 cheerio 的 ast。传入的 fn 接收 cheerioAPI 并且返回它。另外 fn 还可以接收`{ path }` 作为它的第二个参数，该参数代表路由的 path```tsapi.modifyHTML(($, { path }) => {  $('h2').addClass('welcome');  return $;})```"
            },
            {
              "title": "modifyHTMLFavicon",
              "md": "modifyHTMLFavicon修改 HTML 的 favicon 路径。 传入的 fn 接收原本的 favicon 路径(string 类型)并且返回它。"
            },
            {
              "title": "modifyPaths",
              "md": "modifyPaths修改 paths，比如 absOutputPath、absTmpPath。传入的 fn 接收 paths 并且返回它。paths 的接口如下：```tspaths:{  cwd?: string;  absSrcPath?: string;  absPagesPath?: string;  absTmpPath?: string;  absNodeModulesPath?: string;  absOutputPath?: string;}```"
            },
            {
              "title": "modifyRendererPath",
              "md": "modifyRendererPath修改 renderer path。传入的 fn 接收原本的 path （string 类型）并且返回它。"
            },
            {
              "title": "modifyServerRendererPath",
              "md": "modifyServerRendererPath修改 server renderer path。传入的 fn 接收原本的 path （string 类型）并且返回它。"
            },
            {
              "title": "modifyRoutes",
              "md": "modifyRoutes修改路由。 传入的 fn 接收 id-route 的 map 并且返回它。其中 route 的接口如下：```tsinterface IRoute {  path: string;  file?: string;  id: string;  parentId?: string;  [key: string]: any;}```e.g.```tsapi.modifyRoutes((memo) => {  Object.keys(memo).forEach((id) => {    const route = memo[id];    if(route.path === '/'){      route.path = '/redirect'    }  });  return memo;})```"
            },
            {
              "title": "modifyTSConfig",
              "md": "modifyTSConfig修改临时目录下的 tsconfig 文件内容。```tsapi.modifyTSConfig((memo) => {  memo.compilerOptions.paths['foo'] = ['bar'];  return memo;});```"
            },
            {
              "title": "modifyViteConfig",
              "md": "modifyViteConfig修改 vite 最终配置。 传入的 fn 接收 vite 的 Config 对象作为第一个参数并且返回它。另外 fn 还可以接收`{ env }` 作为第二个参数，可以通过该参数获取当前的环境。```tsapi.modifyViteConfig((memo, { env }) => {  if(env === 'development'){    // do something  }  return memo;})```"
            },
            {
              "title": "modifyWebpackConfig",
              "md": "modifyWebpackConfig修改 webpack 最终配置。传入的 fn 接收 webpack 的 Config 对象作为第一个参数并且返回它。另外 fn 还可以接收`{ webpack, env }` 作为第二个参数，其中 webpack 是 webpack 实例，env 代表当前环境。```tsapi.modifyWebpackConfig((memo, { webpack, env }) => {  // do something    return memo;})```"
            },
            {
              "title": "onBeforeCompiler",
              "md": "onBeforeCompilergenerate 之后，webpack / vite compiler 之前。传入的 fn 不接收任何参数。"
            },
            {
              "title": "onBeforeMiddleware",
              "md": "onBeforeMiddleware提供在服务器内部执行所有其他中间件之前执行自定义中间件的能力, 这可以用来定义自定义处理程序， 例如:```tsapi.onBeforeMiddleware(({ app }) => {  app.get('/some/path', function (req, res) {    res.json({ custom: 'response' });  });});```"
            },
            {
              "title": "onBuildComplete",
              "md": "onBuildCompletebuild 完成时。传入的 fn 接收`{ isFirstCompile: boolean, stats, time: number, err?: Error }` 作为参数。"
            },
            {
              "title": "onBuildHtmlComplete",
              "md": "onBuildHtmlCompletebuild 完成且 html 完成构建之后。"
            },
            {
              "title": "onCheck",
              "md": "onCheck检查时，在 onStart 之前执行。传入的 fn 不接收任何参数"
            },
            {
              "title": "onCheckCode",
              "md": "onCheckCode检查代码时。传入的 fn 接收的参数接口如下：```tsargs: {  file: string;  code: string;  isFromTmp: boolean;  imports: {    source: string;    loc: any;    default: string;    namespace: string;    kind: babelImportKind;    specifiers: Record<string, { name: string; kind: babelImportKind }>;  }[];  exports: any[];  cjsExports: string[]; }```"
            },
            {
              "title": "onCheckConfig",
              "md": "onCheckConfig检查 config 时。传入的 fn 接收`{ config, userConfig }`作为参数，它们分别表示实际的配置和用户的配置。"
            },
            {
              "title": "onCheckPkgJSON",
              "md": "onCheckPkgJSON检查 package.json 时。传入的 fn 接收`{origin?, current}` 作为参数。它们的类型都是 package.json 对象"
            },
            {
              "title": "onDevCompileDone",
              "md": "onDevCompileDonedev 完成时。传入的 fn 接收的参数接口如下：```tsargs: {  isFirstCompile: boolean;  stats: any;  time: number; }```"
            },
            {
              "title": "onGenerateFiles",
              "md": "onGenerateFiles生成临时文件时，随着文件变化会频繁触发，有缓存。 传入的 fn 接收的参数接口如下：```tsargs: {  isFirstTime?: boolean;  files?: {    event: string;    path: string;  } | null;}```"
            },
            {
              "title": "onPatchRoute",
              "md": "onPatchRoute匹配单个路由，可以修改路由，给路由打补丁"
            },
            {
              "title": "onPkgJSONChanged",
              "md": "onPkgJSONChangedpackage.json 变更时。传入的 fn 接收`{origin?, current}` 作为参数。它们的类型都是 package.json 对象"
            },
            {
              "title": "onPrepareBuildSuccess",
              "md": "onPrepareBuildSuccess"
            },
            {
              "title": "onStart",
              "md": "onStart启动时。传入的 fn 不接收任何参数。"
            },
            {
              "title": "writeTmpFile",
              "md": "writeTmpFile`api.writeTmpFile()`的 type 参数的类型。content: 写入的文本内容，有内容就不会使用模板。context: 模板上下文。noPluginDir: 是否使用插件名做为目录。path: 写入文件的路径。tpl: 使用模板字符串，没有模板路径会使用它。tplPath: 使用模板文件的路径。"
            }
          ],
          "md": "扩展方法\n通过\n`api.registerMethod()`\n 扩展的方法，它们的作用都是注册一些 hook 以供使用，因此都需要接收一个 fn。这些方法中的大部分都按照 \n`add-`\n \n`modify-`\n \n`on-`\n 的方式命名，它们分别对应了 \n`api.ApplyPluginsType`\n的三种方式，不同方式接收的 fn 不太相同，详见 \nregister\n 一节。\n注意： 下文提到的所有 fn 都可以是同步的或者异步的（返回一个 Promise 即可）。fn 都可以被\n```ts\n{\n  fn,\n  name?: string,\n  before?: string | string[],\n  stage: number,\n}\n\n```\n代替。其中各个参数的作用详见 \ntapable\n"
        },
        {
          "title": "属性",
          "property": [
            {
              "title": "appData",
              "md": "appData"
            },
            {
              "title": "args",
              "md": "args命令行参数，这里去除了命令本身。e.g.`$ umi dev --foo`,  args 为`{ _:[], foo: true }``$ umi g page index --typescript --less` , args 为`{ _: [ 'page', 'index''], typescript: true, less: true }`"
            },
            {
              "title": "config",
              "md": "config最终的配置（取决于你访问的时机，可能是当前收集到的最终配置）"
            },
            {
              "title": "cwd",
              "md": "cwd当前路径"
            },
            {
              "title": "env",
              "md": "env即`process.env.NODE_ENV` 可能有`development`、`production` 和`test`"
            },
            {
              "title": "logger",
              "md": "logger插件日志对象，包含`{ log, info, debug, error, warn, profile }`，他们都是方法。其中`api.logger.profile` 可用于性能耗时记录。```tsapi.logger.profile('barId');setTimeout(() => {  api.logger.profile('barId');})// profile - barId Completed in 6254ms```"
            },
            {
              "title": "name",
              "md": "name当前命令的名称，例如`$ umi dev `，`name` 就是`dev`"
            },
            {
              "title": "paths",
              "md": "paths项目相关的路径：`absNodeModulesPath`，node_modules 目录绝对路径`absOutputPath`，输出路径，默认是 ./dist`absPagesPath`，pages 目录绝对路径`absSrcPath`，src 目录绝对路径，需注意 src 目录是可选的，如果没有 src 目录，absSrcPath 等同于 cwd`absTmpPath`，临时目录绝对路径`cwd`，当前路径注意： 注册阶段不能获取到。因此不能在插件里直接获取，要在 hook 里使用。"
            },
            {
              "title": "pkg",
              "md": "pkg当前项目的`package.json` 对象"
            },
            {
              "title": "pkgPath",
              "md": "pkgPath当前项目的`package.json` 的绝对路径。"
            },
            {
              "title": "plugin",
              "md": "plugin当前插件的对象。`type` 插件类型，有 preset 和 plugin 两种`path` 插件路径`id` 插件 id`key` 插件 key`config` 插件的配置`enableBy` 插件的启用方式注意： 注册阶段使用的 plugin 对象是你`describe` 之前的对象。"
            },
            {
              "title": "service",
              "md": "serviceUmi 的`Service` 实例。通常不需要用到，除非你知道为什么。"
            },
            {
              "title": "userConfig",
              "md": "userConfig用户的配置，从`.umirc` 或`config/config` 中读取的内容，没有经过 defaultConfig 以及插件的任何处理。可以在注册阶段使用。"
            },
            {
              "title": "ApplyPluginsType",
              "md": "ApplyPluginsType`api.applyPlugins()` 的 type 参数的类型。包含addmodifyevent"
            },
            {
              "title": "ConfigChangeType",
              "md": "ConfigChangeType为`api.describe()` 提供`config.onChange` 的类型，目前包含两种：restart，重启 dev 进程，是默认值regenerateTmpFiles，重新生成临时文件"
            },
            {
              "title": "EnableBy",
              "md": "EnableBy插件的启用方式，包含三种：registerconfig"
            },
            {
              "title": "ServiceStage",
              "md": "ServiceStageUmi service 的运行阶段。有如下阶段：uninitializedinitinitPresetsinitPluginsresolveConfigcollectAppDataonCheckonStartrunCommand"
            }
          ],
          "md": "属性\n从 api 可以直接访问到的属性，这些属性有一部分来自于 service\n"
        }
      ]
    }
  ],
  [
    {
      "title": "配置",
      "properties": [
        {
          "title": "alias",
          "property": [],
          "md": "alias\n类型：\n`Record<string, string>`\n默认值：\n`{}`\n配置别名，对 import 语句的 source 做映射。\n比如：\n```js\n{\n  alias: {\n    foo: '/tmp/to/foo',\n  }\n}\n```\n然后代码里 \n`import 'foo'`\n 实际上会 \n`import '/tmp/to/foo'`\n。\n有几个 Tip。\n1、alias 的值最好用绝对路径，尤其是指向依赖时，记得加 \n`require.resolve`\n，比如，\n```js\n// ⛔\n{\n  alias: {\n    foo: 'foo',\n  }\n}\n\n// ✅\n{\n  alias: {\n    foo: require.resolve('foo'),\n  }\n}\n```\n2、如果不需要子路径也被映射，记得加 \n`$`\n 后缀，比如\n```js\n// import 'foo/bar' 会被映射到 import '/tmp/to/foo/bar'\n{\n  alias: {\n    foo: '/tmp/to/foo',\n  }\n}\n\n// import 'foo/bar' 还是 import 'foo/bar'，不会被修改\n{\n  alias: {\n    foo$: '/tmp/to/foo',\n  }\n}\n```\n"
        },
        {
          "title": "autoprefixer",
          "property": [],
          "md": "autoprefixer\n类型：\n`object`\n默认值：\n`{ flexbox: 'no-2009' }`\n用于解析 CSS 并使用来自 Can I Use 的值将供应商前缀添加到 CSS 规则。如自动给 CSS 添加 \n`-webkit-`\n 前缀。\n更多配置，请查阅 \nautoprefixer 的配置项\n。\n"
        },
        {
          "title": "analyze",
          "property": [],
          "md": "analyze\n类型：\n`object`\n默认值：\n`{}`\n通过指定 \n`ANALYZE`\n 环境变量分析产物构成时，analyzer 插件的具体配置项，见 \nwebpack-bundle-analyzer\n使用 Vite 模式时，除了可以自定义 \nrollup-plugin-visualizer\n 的配置， \n`excludeAssets`\n、\n`generateStatsFile`\n、\n`openAnalyzer`\n、\n`reportFilename`\n、\n`reportTitle`\n 这些选项会自动转换适配。\n"
        },
        {
          "title": "base",
          "property": [],
          "md": "base\n类型：\n`string`\n默认值：\n`/`\n要在非根目录下部署 umi 项目时，你可以使用 base 配置。\nbase 配置允许你为应用程序设置路由前缀。比如有路由 \n`/`\n 和 \n`/users`\n，设置 base 为 \n`/foo/`\n 后就可通过 \n`/foo/`\n 和 \n`/foo/users`\n 访问到之前的路由。\n注意：base 配置必须在构建时设置，并且不能在不重新构建的情况下更改，因为该值内联在客户端包中。\n"
        },
        {
          "title": "cacheDirectoryPath",
          "property": [],
          "md": "cacheDirectoryPath\n类型：\n`string`\n默认值：\n`node_modules/.cache`\n默认情况下 Umi 会将构建中的一些缓存文件存放在 \n`node_modules/.cache`\n 目录下，比如 logger 日志，webpack 缓存，mfsu 缓存等。你可以通过使用 \n`cacheDirectoryPath`\n 配置来修改 Umi 的缓存文件目录。\n示例，\n```js\n// 更改缓存文件路径到 node_modules/.cache1 文件夹\ncacheDirectoryPath: 'node_modules/.cache1',\n```\n"
        },
        {
          "title": "chainWebpack",
          "property": [],
          "md": "chainWebpack\n类型：\n`(memo, args) => void`\n默认值：\n`null`\n为了扩展 Umi 内置的 webpack 配置，我们提供了用链式编程的方式修改 webpack 配置，基于 webpack-chain，具体 API 可参考 \nwebpack-api 的文档\n。\n如下所示：\n```js\nexport default {\n  chainWebpack(memo, args) {\n    return memo;\n  },\n};\n```\n该函数具有两个参数：\n`memo`\n 是现有 webpack 配置\n`args`\n 包含一些额外信息和辅助对象，目前有 \n`env`\n 和 \n`webpack`\n。\n`env`\n 为当前环境，值为 \n`development`\n 或 \n`production`\n；\n`webpack`\n 为 webpack 对象，可从中获取 webpack 内置插件等\n用法示例：\n```js\nexport default {\n  chainWebpack(memo, { env, webpack }) {\n    // 设置 alias\n    memo.resolve.alias.set('foo', '/tmp/to/foo');\n\n    // 添加额外插件\n    memo.plugin('hello').use(Plugin, [...args]);\n\n    // 删除 Umi 内置插件\n    memo.plugins.delete('hmr');\n  },\n};\n```\n"
        },
        {
          "title": "clickToComponent",
          "property": [],
          "md": "clickToComponent\n类型: \n`{ editor?: string }`\n默认值: \n`false`\n当前仅 React 项目支持。\n开启后，可通过 \n`Option+Click/Alt+Click`\n 点击组件跳转至编辑器源码位置，\n`Option+Right-click/Alt+Right-click`\n 可以打开上下文，查看父组件。\n关于参数。\n`editor`\n 为编辑器名称，默认为 'vscode'，支持 \n`vscode`\n & \n`vscode-insiders`\n。\n配置 clickToComponent 的行为，详见 \nclick-to-component\n。\n示例：\n```ts\n// .umirc.ts\nexport default {\n  clickToComponent: {},\n};\n```\n"
        },
        {
          "title": "clientLoader",
          "property": [],
          "md": "clientLoader\n类型: \n`{}`\n默认值: \n`false`\n开启后，可以为每个路由声明一个数据加载函数 \n`clientLoader`\n，将页面需要的加载数据程序提取到 \n`clientLoader`\n 可以让 Umi\n提前在页面组件尚未加载好的时候提前进行数据的加载，避免瀑布流请求的问题，详细介绍请看 \n路由数据预加载\n。\n示例：\n```ts\n// .umirc.ts\nexport default {\n  clientLoader: {},\n};\n```\n配置开启后，在路由组件中使用：\n```jsx\n// pages/.../some_page.tsx\n\nimport { useClientLoaderData } from 'umi';\n\nexport default function SomePage() {\n  const { data } = useClientLoaderData();\n  return <div>{data}</div>;\n}\n\nexport async function clientLoader() {\n  const data = await fetch('/api/data');\n  return data;\n}\n```\n"
        },
        {
          "title": "codeSplitting",
          "property": [],
          "md": "codeSplitting\n类型：\n`{ jsStrategy: 'bigVendors' | 'depPerChunk' | 'granularChunks'; jsStrategyOptions: {} }`\n默认值：\n`null`\n提供 code splitting 的策略方案。\nbigVendors 是大 vendors 方案，会将 async chunk 里的 node_modules 下的文件打包到一起，可以避免重复。同时缺点是，1）单文件的尺寸过大，2）毫无缓存效率可言。\ndepPerChunk 和 bigVendors 类似，不同的是把依赖按 package name + version 进行拆分，算是解了 bigVendors 的尺寸和缓存效率问题。但同时带来的潜在问题是，可能导致请求较多。我的理解是，对于非大型项目来说其实还好，因为，1）单个页面的请求不会包含非常多的依赖，2）基于 HTTP/2，几十个请求不算问题。但是，对于大型项目或巨型项目来说，需要考虑更合适的方案。\ngranularChunks 在 bigVendors 和 depPerChunk 之间取了中间值，同时又能在缓存效率上有更好的利用。无特殊场景，建议用 granularChunks 策略。\n"
        },
        {
          "title": "conventionLayout",
          "property": [],
          "md": "conventionLayout\n类型：\n`boolean`\n默认值：\n`undefined`\n`src/layouts/index.[tsx|vue|jsx|js]`\n 为约定式布局，默认开启。可通过配置 \n`conventionLayout: false`\n 关闭该默认行为。\n"
        },
        {
          "title": "conventionRoutes",
          "property": [
            {
              "title": "base",
              "md": "base`base` 用于设置约定的路由的基础路径，默认从`src/pages` 读取，如果是文档站点可能会需要将其改成`./docs`；"
            },
            {
              "title": "exclude",
              "md": "exclude你可以使用`exclude` 配置过滤一些不需要的文件，比如用于过滤 components、models 等。示例，```js// 不识别 components 和 models 目录下的文件为路由conventionRoutes: {  exclude: [/\\/components\\//, /\\/models\\//],}```"
            }
          ],
          "md": "conventionRoutes\n类型：\n`{ base: string; exclude: RegExp[] }`\n默认值：\n`null`\n修改默认的约定式路由规则，仅在使用 umi 约定式路由时有效，约定式路由也叫文件路由，就是不需要手写配置，文件系统即路由，通过目录和文件及其命名分析出路由配置。\n使用约定式路由时，约定 \n`src/pages`\n 下所有的 \n`(j|t)sx?`\n 文件即路由。\n你可以从\n约定式路由\n查看更多说明。\n"
        },
        {
          "title": "copy",
          "property": [],
          "md": "copy\n类型：\n`Array<string | { from: string; to: string; }>`\n默认值：\n`[]`\n配置要复制到输出目录的文件或文件夹。\n当配置字符串时，默认拷贝到产物目录，如：\n```ts\ncopy: ['foo.json', 'src/bar.json']\n```\n会产生如下产物的结构：\n```\n+ dist\n  - bar.json\n  - foo.json\n+ src\n  - bar.json\n- foo.json\n```\n你也可以通过对象配置具体的拷贝位置，其中相对路径的起点为项目根目录：\n```ts\ncopy: [\n  { from: 'from', to: 'dist/output' },\n  { from: 'file.json', to: 'dist' }\n]\n```\n此时将产生如下产物结构：\n```\n+ dist\n  + output\n    - foo.json\n  - file.json\n+ from\n  - foo.json\n- file.json\n```\n"
        },
        {
          "title": "crossorigin",
          "property": [],
          "md": "crossorigin\n类型：\n`{ includes?: string[] }`\n默认值：\n`false`\n配置 script 标签的 crossorigin。如果有声明，会为本地 script 加上 crossorigin=\"anonymous\" 的属性。\n关于参数。\n`includes`\n 参数可以为额外的非本地 script 标签加上此属性。\n比如：\n```\ncrossorigin: {}\n```\n然后输出的 HTML 中会有这些变化，\n```diff\n-\n<script src=\"/umi.js\"></script>\n+\n<script src=\"/umi.js\" crossorigin=\"anonymous\"></script>\n```\n"
        },
        {
          "title": "cssMinifier",
          "property": [],
          "md": "cssMinifier\n类型：\n`string`\n 可选的值：\n`esbuild`\n, \n`cssnano`\n, \n`parcelCSS`\n, \n`none`\n默认值：\n`esbuild`\n配置构建时使用的 CSS 压缩工具; \n`none`\n 表示不压缩。\n示例：\n```js\n{\n  cssMinifier: 'esbuild'\n}\n```\n"
        },
        {
          "title": "cssMinifierOptions",
          "property": [],
          "md": "cssMinifierOptions\n类型：\n`object`\n默认值：\n`{}`\n`cssMinifier`\n CSS 压缩工具配置选项。\n示例：\n```js\n{\n  cssMinifier: 'esbuild',\n  cssMinifierOptions: {\n    minifyWhitespace: true,\n    minifySyntax: true,\n  },\n}\n```\n对应 CSS 压缩的配置请查看对应的文档。\nesbuild 参考\ncssnano 参考\nparcelCSS 参考\n"
        },
        {
          "title": "cssPublicPath",
          "property": [],
          "md": "cssPublicPath\n类型：\n`string`\n默认值：\n`./`\n为 CSS 中的图片、文件等外部资源指定自定义公共路径。作用类似于 \n`publicPath`\n 默认值是 \n`./`\n。\n"
        },
        {
          "title": "cssLoader",
          "property": [],
          "md": "cssLoader\n类型：\n`object`\n默认值：\n`{}`\n配置 css-loader ，详见 \ncss-loader > options\n"
        },
        {
          "title": "cssLoaderModules",
          "property": [],
          "md": "cssLoaderModules\n类型：\n`object`\n默认值：\n`{}`\n配置 css modules 的行为，详见 \ncss-loader > modules\n。\n如：\n```ts\ncssLoaderModules: {\n  // 配置驼峰式使用\n  exportLocalsConvention: 'camelCase'\n}\n```\n"
        },
        {
          "title": "deadCode",
          "property": [],
          "md": "deadCode\n类型：\n`{ patterns?: string[]; exclude?: string[]; failOnHint?: boolean; detectUnusedFiles?: boolean; detectUnusedExport?: boolean; context?: string }`\n默认值：\n`false`\n检测未使用的文件和导出，仅在 build 阶段开启。\n比如：\n```\ndeadCode: {}\n```\n然后执行 build，如有发现问题，会打印警告：\n```\nWarning: There are 1 unused files:\n 1. /pages/index.module.less\n Please be careful if you want to remove them (¬º-°)¬.\n```\n可配置项：\n`patterns`\n : 识别代码的范围，如 \n`['src/pages/**']`\n`exclude`\n : 排除检测的范围，如 \n`['src/pages/utils/**']`\n`failOnHint`\n : 检测失败是否终止进程，默认 \n`false`\n 不终止\n`detectUnusedFiles`\n : 是否检测未使用的文件，默认 \n`true`\n 检测\n`detectUnusedExport`\n : 是否检测未使用的导出，默认 \n`true`\n 检测\n`context`\n : 匹配开始的目录，默认为当前项目根目录\n"
        },
        {
          "title": "define",
          "property": [],
          "md": "define\n类型：\n`Record<string, string>`\n默认值： 如下\n```\n  { \n    'process.env.NODE_ENV' : process.env.NODE_ENV,\n    'process.env.HMR' : process.env.HMR, \n    'process.env.SOCKET_SERVER': process.env.ERROR_OVERLAY' \n  }\n```\n基于\ndefine-plugin 插件\n设置代码中的可用变量。\n:::warning{title=🚨}\n属性值会经过一次 \n`JSON.stringify`\n 转换。\nkey 值的替换是通过语法形式来匹配的，比如配置了 \n`{'a.b.c': 'abcValue'}`\n 是无法替换代码中的  \n`a.b?.c`\n 的\n:::\n比如，\n```\ndefine: { FOO: 'bar' }\n```\n然后代码里的 \n`console.log(hello, FOO)`\n 会被编译成 \n`console.log(hello, 'bar')`\n。\n当你在 ts 的项目中使用这些变量时，你需要在 typings 文件中声明变量类型，以支持 ts 类型提示，比如：\n如果你的 typings 文件是全局的：\n```ts\n// typings.d.ts\ndeclare const FOO: string;\n```\n如果你的 typings 文件是非全局的（包含了 import/export）：\n```ts\n// typings.d.ts\nimport './other.d.ts';\n\ndeclare global {\n const FOO: string;\n}\n```\n"
        },
        {
          "title": "devtool",
          "property": [],
          "md": "devtool\n类型：\n`string`\n默认值：dev 时默认 \n`cheap-module-source-map`\n，build 时候默认无 sourcemap\n设置 sourcemap 生成方式。\n常见可选值有：\n`eval`\n，最快的类型，缺点是不支持低版本浏览器\n`source-map`\n，最慢但最全的类型\n示例，\n```js\n// 关闭 dev 阶段的 sourcemap 生成\ndevtool: false;\n\n// 只设置 dev 阶段的 sourcemap\ndevtool: process.env.NODE_ENV === 'development' ? 'eval' : false;\n```\n"
        },
        {
          "title": "classPropertiesLoose",
          "property": [],
          "md": "classPropertiesLoose\n类型：\n`object`\n默认值：\n`{}`\n设置 babel class-properties 启用 loose\n"
        },
        {
          "title": "esbuildMinifyIIFE",
          "property": [],
          "md": "esbuildMinifyIIFE\n类型：\n`boolean`\n默认值：\n`false`\n修复 esbuild 压缩器自动引入的全局变量导致的命名冲突问题。\n由于 Umi 4 默认使用 esbuild 作为压缩器，该压缩器会自动注入全局变量作为 polyfill ，这可能会引发 异步块全局变量冲突、 qiankun 子应用和主应用全局变量冲突 等问题，通过打开该选项或切换 \n`jsMinifier`\n 压缩器可解决此问题。\n更多信息详见 \nvite#7948\n 。\n示例,\n```ts\nesbuildMinifyIIFE: true\n```\n"
        },
        {
          "title": "externals",
          "property": [],
          "md": "externals\n类型：\n`Record<string, string> | Function`\n默认值：\n`{}`\n设置哪些模块不打包，转而通过 \n`<script>`\n 或其他方式引入，通常需要搭配 headScripts 配置使用。\n示例，\n```\n// external react\nexternals: { react: 'React' },\nheadScripts: ['https://unpkg.com/react@17.0.1/umd/react.production.min.js'],\n```\n注意：不要轻易设置 antd 的 externals，由于依赖较多，使用方式复杂，可能会遇到较多问题，并且一两句话很难解释清楚。\n"
        },
        {
          "title": "extraBabelIncludes",
          "property": [],
          "md": "extraBabelIncludes\n类型：\n`Array<string | RegExp>`\n默认值：\n`[]`\n配置额外需要做 Babel 编译的 NPM 包或目录。比如：\n```js\nexport default {\n  extraBabelIncludes: [\n    // 支持绝对路径\n    join(__dirname, '../../common'),\n    // 支持 npm 包\n    'react-monaco-editor',\n    // 转译全部路径含有 @scope 的包\n    /@scope/\n  ],\n};\n```\n"
        },
        {
          "title": "extraBabelPlugins",
          "property": [],
          "md": "extraBabelPlugins\n类型：\n`string[] | Function`\n默认值：\n`[]`\n配置额外的 babel 插件。可传入插件地址或插件函数。\n"
        },
        {
          "title": "extraBabelPresets",
          "property": [],
          "md": "extraBabelPresets\n类型：\n`string[] | Function`\n默认值：\n`[]`\n配置额外的 babel 插件集。可传入插件集地址或插件集函数。\n"
        },
        {
          "title": "extraPostCSSPlugins",
          "property": [],
          "md": "extraPostCSSPlugins\n类型：\n`PostCSSPlugin[]`\n默认值：\n`[]`\n配置额外的 postcss 插件。\n"
        },
        {
          "title": "exportStatic",
          "property": [],
          "md": "exportStatic\n类型：\n`{ extraRoutePaths: IUserExtraRoute[] | (() => IUserExtraRoute[] | Promise<IUserExtraRoute[]>), ignorePreRenderError: boolean }`\n默认值：\n`undefined`\n开启该配置后会针对每个路由单独输出 HTML 文件，通常用于静态站点托管。例如项目有如下路由：\n```bash\n/\n/docs\n/docs/a\n```\n不开启 \n`exportStatic`\n 时会输出：\n```bash\ndist/index.html\n```\n开启 \n`exportStatic`\n 时会输出：\n```bash\ndist/index.html\ndist/docs/index.html\ndist/docs/a/index.html\n```\n通过 \n`extraRoutePaths`\n 子配置项可以产出额外的页面，通常用于动态路由静态化。例如有如下路由：\n```bash\n/news/:id\n```\n默认情况下只会输出 \n`dist/news/:id/index.html`\n，但可以通过配置 \n`extraRoutePaths`\n 将其静态化：\n```ts\n// .umirc.ts\nexport default {\n  exportStatic: {\n    // 配置固定值\n    extraRoutePaths: ['/news/1', '/news/2'],\n    // 也可以配置函数动态获取\n    extraRoutePaths: async () => {\n      const res = await fetch('https://api.example.com/news');\n      const data = await res.json();\n      return data.map((item) => `/news/${item.id}`);\n    },\n  },\n}\n```\n此时输出文件会变成：\n```bash\ndist/news/:id/index.html\ndist/news/1/index.html\ndist/news/2/index.html\n```\n`extraRoutePaths`\n 除了支持配置字符串数据，还可以配置成对象数组，用于启用 SSR 时又希望对部分路由禁用预渲染的场景，例如：\n```ts\n// .umirc.ts\nexport default {\n  exportStatic: {\n    // 输出额外页面文件但跳过预渲染\n    extraRoutePaths: [{ path: '/news/1', prerender: false }],\n  },\n}\n```\n`exportStatic`\n 在搭配 \n`ssr`\n 使用时会进行预渲染，在预渲染失败时会抛出异常并终止构建，可以通过配置 \n`ignorePreRenderError`\n 来忽略预渲染失败的错误，例如：\n```ts\n// .umirc.ts\nexport default {\n  exportStatic: {\n    // 忽略预渲染失败的错误\n    ignorePreRenderError: true,\n  },\n}\n```\n"
        },
        {
          "title": "favicons",
          "property": [],
          "md": "favicons\n类型：\n`string[]`\n默认值：\n`null`\n默认情况下，站点将使用约定 \n`favicon`\n 来创建图标的 meta 头标签。\n通过如下方式自定义：\n```js\nfavicons: [\n  // 完整地址\n  'https://domain.com/favicon.ico',\n  // 此时将指向 `/favicon.png` ，确保你的项目含有 `public/favicon.png`\n  '/favicon.png'\n]\n```\n"
        },
        {
          "title": "forkTSChecker",
          "property": [],
          "md": "forkTSChecker\n类型：\n`object`\n默认值：\n`null`\n开启 TypeScript 的类型检查。基于 fork-ts-checker-webpack-plugin，配置项可参考 \nfork-ts-checker-webpack-plugin 的 Options\n。\n"
        },
        {
          "title": "hash",
          "property": [],
          "md": "hash\n类型：\n`boolean`\n默认值：\n`false`\n开启 hash 模式，让 build 之后的产物包含 hash 后缀。通常用于增量发布和避免浏览器加载缓存。\n启用后，产物通常是这样，\n```\n+ dist\n    - logo.sw892d.png\n    - umi.df723s.js\n    - umi.8sd8fw.css\n    - index.html\n```\n注意：HTML 文件始终没有 hash 后缀。\n"
        },
        {
          "title": "headScripts",
          "property": [],
          "md": "headScripts\n类型：\n`string[] | Script[]`\n默认值：\n`[]`\n配置 \n`<head>`\n 中的额外 script。\n比如，\n```js\nheadScripts: [`alert(1);`, `https://a.com/b.js`],\n```\n会生成 HTML，\n```html\n<script>\n  alert(1);\n</script>\n<script src=\"https://a.com/b.js\"></script>\n```\n如果需要额外属性，切换到对象格式，比如，\n```js\nheadScripts: [\n  { src: '/foo.js', defer: true },\n  { content: `alert('你好');`, charset: 'utf-8' },\n],\n```\n"
        },
        {
          "title": "helmet",
          "property": [],
          "md": "helmet\n类型：\n`boolean`\n默认值：\n`true`\n配置 \n`react-helmet-async`\n 的集成，当设置为 \n`false`\n 时，不会集成 \n`react-helmet-async`\n，此时无法从框架中 \n`import { Helmet }`\n 使用，同时构建产物也会减少\n相应的尺寸\n。\n"
        },
        {
          "title": "history",
          "property": [],
          "md": "history\n类型：\n`{ type: 'browser' | 'hash' | 'memory' }`\n默认值：\n`{ type: 'browser' }`\n设置路由 history 类型。\n"
        },
        {
          "title": "historyWithQuery",
          "property": [],
          "md": "historyWithQuery\n类型：\n`‌{}`\n默认值：\n`false`\n让 history 带上 query。除了通过 \n`useNavigate`\n 进行的跳转场景，此时还需自行处理 query。\n"
        },
        {
          "title": "https",
          "property": [],
          "md": "https\n类型：\n`{ cert: string; key: string; hosts: string[]; http2?: boolean }`\n默认值：\n`{ hosts: ['127.0.0.1', 'localhost'] }`\n开启 dev 的 https 模式，Umi 4 默认使用 \n`mkcert`\n 快捷创建证书，请确保已经安装。\n关于参数。\n`cert`\n 和 \n`key`\n 分别用于指定 cert 和 key 文件。\n`hosts`\n 用于指定要支持 https 访问的 host，默认是 \n`['127.0.0.1', 'localhost']`\n。\n`http2`\n 用于指定是否使用 HTTP 2.0 协议，默认是 true（使用 HTTP 2.0 在 Chrome 或 Edge 浏览器中中有偶然出现 \n`ERR_HTTP2_PROTOCOL_ERRO`\n报错，如有遇到，建议配置为 false）。\n示例，\n```js\nhttps: {\n}\n```\n"
        },
        {
          "title": "icons",
          "property": [
            {
              "title": "icon 集使用",
              "md": "icon 集使用在 umi 配置文件设置，开启 icons 功能，并允许自动安装图标库。```tsicons: { autoInstall: {} },```页面使用：```tsimport { Icon } from 'umi';<Icon icon=\"fa:home\" />```icon 里包含的字符串是`collect:icon` 的组合，以`:` 分割。Icon 集推荐在Icônes 网站上搜索。"
            }
          ],
          "md": "icons\n类型：\n`{ autoInstall: {}; alias: Record<string,string>; include: Array<string>;  }`\n默认值：\n`false`\n你就可以通过 umi 导出的 Icon 组件快捷地引用 icon 集或者本地的 icon。\n"
        },
        {
          "title": "本地 icon 使用",
          "property": [
            {
              "title": "配置项介绍",
              "md": "配置项介绍`autoInstall` 表示是否自动安装 icon 集；tnpm/cnpm 客户端暂不支持，但可以通过手动按需安装对应 icon 集合包`@iconify-json/collection-name` 。 参考：Icon 集合列表, collection-name 为列表中的Icon set prefix 项。`alias` 用于配置 icon 的别名，比如配置了`alias:{home:'fa:home'}` 后就可以通过`icon=\"home\"` 使用`fa:home` 这个 icon 了。`include` 配置需要强制使用的 icon， 例如`include: ['fa:home', 'local:icon']`。常见的使用场景：将 icon 字符串定义在一个 map 中，导致无法检测到；在`mdx` 使用了`Icon` 组件。"
            },
            {
              "title": "Icon 组件属性",
              "md": "Icon 组件属性icon，指定 iconwidth，svg 宽度height，svg 高度viewBox，svg viewBoxstyle，外部容器样式className，外部容器样式名spin，是否自动旋转rotate，配置旋转角度，支持多种格式，比如`1`，`\"30deg\"`、`\"25%\"` 都可以flip，支持`vertical`、`horizontal`，或者他们的组合`vertical,horizontal`"
            }
          ],
          "md": "本地 icon 使用\n在 umi 配置文件设置，开启 icons 功能。\n```ts\nicons: {},\n```\n本地 svg icon 的使用需要把 svg 保存在 \n`src/icons`\n 目录下，然后通过 \n`local`\n 这个前缀引用，比如在 \n`src/icons`\n 目录下有个 \n`umi.svg`\n，然后可以这样引用。\n```tsx\nimport { Icon } from 'umi';\n<Icon icon=\"local:umi\" />\n```\n"
        },
        {
          "title": "ignoreMomentLocale",
          "property": [],
          "md": "ignoreMomentLocale\n类型：\n`boolean`\n默认值：\n`true`\n忽略 moment 的 locale 文件，用于减少产物尺寸。\n注意：此功能默认开。配置 \n`ignoreMomentLocale: false`\n 关闭。\n"
        },
        {
          "title": "inlineLimit",
          "property": [],
          "md": "inlineLimit\n类型：\n`number`\n默认值：\n`10000`\n (10k)\n配置图片文件是否走 base64 编译的阈值。默认是 10000 字节，少于他会被编译为 base64 编码，否则会生成单独的文件。\n"
        },
        {
          "title": "jsMinifier (webpack)",
          "property": [],
          "md": "jsMinifier (webpack)\n类型：\n`string`\n，可选值 \n`esbuild`\n, \n`terser`\n, \n`swc`\n, \n`uglifyJs`\n, \n`none`\n默认值：\n`esbuild`\n配置构建时压缩 JavaScript 的工具；\n`none`\n表示不压缩。\n示例：\n```ts\n{\n  jsMinifier: 'esbuild'\n}\n```\n"
        },
        {
          "title": "jsMinifierOptions",
          "property": [],
          "md": "jsMinifierOptions\n类型：\n`object`\n默认值：\n`{}`\n`jsMinifier`\n 的配置项；默认情况下压缩代码会移除代码中的注释，可以通过对应的 \n`jsMinifier`\n 选项来保留注释。\n示例：\n```js\n{\n  jsMinifier: 'esbuild',\n  jsMinifierOptions: {\n    minifyWhitespace: true,\n    minifyIdentifiers: true,\n    minifySyntax: true,\n  }\n}\n```\n配置项需要和所使用的工具对应，具体参考对应文档：\nesbuild 参考\nterser 参考\nswc 参考\nuglifyJs 参考\n"
        },
        {
          "title": "lessLoader",
          "property": [],
          "md": "lessLoader\n类型：\n`object`\n默认值：\n`{ modifyVars: userConfig.theme, javascriptEnabled: true }`\n设置 less-loader 的 Options。具体参考参考 \nless-loader 的 Options\n。\n默认是用 less@4 版本，如果需要兼容 less@3 请配置使用\nless-options-math\n。\n"
        },
        {
          "title": "legacy",
          "property": [],
          "md": "legacy\n类型：\n`{ buildOnly?: boolean; nodeModulesTransform?: boolean; checkOutput?: boolean; }`\n默认值：\n`false`\n当你需要兼容低版本浏览器时，可能需要该选项，开启后将默认使用 \n非现代\n 的打包工具做构建，这会显著增加你的构建时间。\n```ts\nlegacy: {}\n```\n默认只在构建时生效，通过设定 \n`buildOnly: false`\n 关闭该限制。\n可通过打开 \n`checkOutput: true`\n 选项，每次构建结束后将自动运行 \n`es-check`\n 检查产物 \n`.js`\n 文件的语法是否为 es5 格式。\n开启此选项后：\n不支持自定义 \n`srcTranspiler`\n 、\n`jsMinifier`\n 、 \n`cssMinifier`\n 选项。\n将转译全部 \n`node_modules`\n 内的源码，\n`targets`\n 兼容至 ie 11 ，通过指定 \n`nodeModulesTransform: false`\n 来取消对 \n`node_modules`\n 的转换，此时你可以通过配置 \n`extraBabelIncludes`\n 更精准的转换那些有兼容性问题的包。\n因低版本浏览器不支持 Top level await ，当你在使用 \n`externals`\n 时，确保你没有在使用异步性质的 \n`externalsType`\n 时又使用了同步导入依赖。\n"
        },
        {
          "title": "links",
          "property": [],
          "md": "links\n类型：\n`Link[]`\n默认值：\n`[]`\n配置额外的 link 标签。\n示例，\n```js\nlinks: [{ href: '/foo.css', rel: 'preload' }],\n```\n"
        },
        {
          "title": "manifest",
          "property": [],
          "md": "manifest\n类型：\n`{ fileName: string; basePath: string }`\n默认值：\n`null`\n开启 build 时生成额外的 manifest 文件，用于描述产物。\n关于参数。\n`fileName`\n 是生成的文件名，默认是 \n`asset-manifest.json`\n；\n`basePath`\n 会给所有文件路径加上前缀。\n注意：只在 build 时生成。\n"
        },
        {
          "title": "mdx",
          "property": [],
          "md": "mdx\n类型：\n`{ loader: string; loaderOptions: Object }`\n默认值：\n`{}`\nmdx loader 配置 loader 配置路径，\nloaderOptions\n 配置参数\n"
        },
        {
          "title": "metas",
          "property": [],
          "md": "metas\n类型：\n`Meta[]`\n默认值：\n`[]`\n配置额外的 meta 标签。\n比如，\n```js\nmetas: [\n  { name: 'keywords', content: 'umi, umijs' },\n  { name: 'description', content: 'React framework.' },\n],\n```\n会生成以下 HTML，\n```html\n<meta name=\"keywords\" content=\"umi, umijs\" />\n<meta name=\"description\" content=\"React framework.\" />\n```\n"
        },
        {
          "title": "mfsu",
          "property": [],
          "md": "mfsu\n类型：\n`{ esbuild: boolean; mfName: string; cacheDirectory: string; strategy: 'normal' | 'eager'; include?: string[]; chainWebpack: (memo, args) => void; exclude?: Array<string | RegExp> }`\n默认值：\n`{ mfName: 'mf', strategy: 'normal' }`\n配置基于 \nModule Federation\n 的提速功能。\n关于参数\n`esbuild`\n 配为 \n`true`\n 后会让依赖的预编译走 esbuild，从而让首次启动更快，缺点是二次编译不会有物理缓存，稍慢一些；推荐项目依赖比较稳定的项目使用。\n`mfName`\n 是此方案的 remote 库的全局变量，默认是 mf，通常在微前端中为了让主应用和子应用不冲突才会进行配置\n`cacheDirectory`\n 可以自定义缓存目录，默认是 \n`node_modules/.cache/mfsu`\n`chainWebpack`\n 用链式编程的方式修改 依赖的 webpack 配置，基于 webpack-chain，具体 API 可参考 \nwebpack-api 的文档\n；\n`runtimePublicPath`\n 会让修改 mf 加载文件的 publicPath 为 \n`window.publicPath`\n`strategy`\n 指定 mfsu 编译依赖的时机; \n`normal`\n 模式下，采用 babel 编译分析后，构建 Module Federation 远端包；\n`eager`\n 模式下采用静态分析的方式，和项目代码同时发起构建。\n`include`\n 仅在 \n`strategy: 'eager' `\n 模式下生效， 用于补偿在 eager 模式下，静态分析无法分析到的依赖，例如 \n`react`\n 未进入 Module Federation 远端模块可以这样配置 \n`{ include: [ 'react' ] }`\n`exclude`\n 手动排除某些不需要被 MFSU 处理的依赖, 字符串或者正则的形式，比如 \n`vant`\n 不希望走 MFSU 处理，可以配置 \n`{ exclude: [ 'vant' ] }`\n 匹配逻辑为全词匹配，也可以配置 \n`{ exclude: [ /vant/ ] }`\n 只要 \n`import`\n 路径中匹配该正则的依赖都不走 MFSU 处理\n示例，\n```js\n// 用 esbuild 做依赖预编译\nmfsu: {\n  esbuild: true,\n}\n\n// 关闭 mfsu 功能\nmfsu: false;\n```\n```js\n// webpack 配置修改\nmfsu: {\n  chainWebpack(memo, args) {\n    // 添加额外插件\n    memo.plugin('hello').use(Plugin, [...args]);\n    return memo;\n  }\n}\n```\n注意：此功能默认开。配置 \n`mfsu: false`\n 关闭。\n"
        },
        {
          "title": "mock",
          "property": [],
          "md": "mock\n类型：\n`{ exclude: string[], include: string[] }`\n默认值：\n`{}`\n配置 mock 功能。\n关于参数。\n`exclude`\n 用于排除不需要的 mock 文件；\n`include`\n 用于额外添加 mock 目录之外的 mock 文件。\n示例，\n```js\n// 让所有 pages 下的 _mock.ts 文件成为 mock 文件\nmock: {\n  include: ['src/pages/**/_mock.ts'],\n}\n```\n注意：此功能默认开。配置 \n`mock: false`\n 关闭。\n"
        },
        {
          "title": "mountElementId",
          "property": [],
          "md": "mountElementId\n类型：\n`string`\n默认值：\n`'root'`\n配置 react 组件树渲染到 HTML 中的元素 id。\n示例，\n```js\nmountElementId: 'container'\n```\n"
        },
        {
          "title": "monorepoRedirect",
          "property": [],
          "md": "monorepoRedirect\n类型：\n`{ srcDir?: string[], exclude?: RegExp[], peerDeps?: boolean, useRootProject?: boolean }`\n默认值：\n`false`\n在 monorepo 中使用 Umi 时，你可能需要引入其他子包的组件、工具方法等，通过开启此选项来重定向这些子包的导入到他们的源码位置（默认为 \n`src`\n 文件夹），这也可以解决 \n`MFSU`\n 场景改动子包不热更新的问题。\n这种重定向的好处是：支持热更新，无需预构建其他子包即可进行开发。\n通过配置 \n`srcDir`\n 来调整识别源码文件夹的优先位置，通过 \n`exclude`\n 来设定不需要重定向的依赖范围。\n示例：\n```js\n// 默认重定向到子包的 src 文件夹\nmonorepoRedirect: {}\n// 在子包中寻找，优先定向到 libs 文件夹\nmonorepoRedirect: {\n  srcDir: ['libs', 'src'],\n}\n// 不重定向 @scope/* 的子包\nmonorepoRedirect: {\n  exclude: [/^@scope\\/.+/],\n}\n```\n在实际的大型业务 monorepo 中，每个子包的依赖都是从他们的目录开始向上寻找 \n`node_modules`\n 并加载的，但在本地开发时，依赖都安装在 \n`devDependencies`\n ，和从 npm 上安装表现不一致，所以不可避免会遇到多实例问题。\n:::info\n举个例子，每个子包在本地开发时都需要 \n`antd`\n ，在 \n`devDependencies`\n 中安装了，也在 \n`peerDependencies`\n 中指明了 \n`antd`\n ，我们预期该包发布到 npm ，被某个项目安装后， \n`antd`\n 是使用的项目本身的依赖，全局唯一，但由于在 monorepo 中，指定在 \n`devDependencies`\n 中的依赖必定存在，且子包代码寻找依赖时是从该子包进行的，导致了每个子包都用了自己的 \n`antd`\n ，出现了产物中有多份 \n`antd`\n 、产物体积增大、消息队列被破坏等情况。\n:::\n为了解决这种问题，我们约定：\n当打开 \n`peerDeps`\n 选项时，所有子包指明的 \n`peerDependencies`\n 都会被自动添加 \n`alias`\n 重定向唯一化，避免多实例的存在：\n```ts\nmonorepoRedirect: { peerDeps: true }\n```\n经过重定向，依赖全局唯一，便可以在开发时保持和在 npm 上安装包后的体验一致。\nuseRootProject: 当你的项目不在 monorepo 子文件夹里，而在 monorepo 根的话，你可以开启这个选项，以使 monorepoRedirect 生效。\n"
        },
        {
          "title": "mpa",
          "property": [],
          "md": "mpa\n类型：\n`object`\n默认值：\n`false`\n启用 \nmpa 模式\n。\n"
        },
        {
          "title": "outputPath",
          "property": [],
          "md": "outputPath\n类型：\n`string`\n默认值：\n`dist`\n配置输出路径。\n注意：不允许设定为 src、public、pages、mock、config、locales、models 等约定式功能相关的目录。\n"
        },
        {
          "title": "phantomDependency",
          "property": [],
          "md": "phantomDependency\n类型：\n`{ exclude: string[] }`\n默认值：\n`false`\n执行幽灵依赖检测。\n当使用未在 package.json 中声明的依赖，以及也没有通过 alias 或 externals 进行配置时，会抛错并提醒。\n![](https://mdn.alipayobjects.com/huamei_ddtbzw/afts/img/A*k5uoQ5TOPooAAAAAAAAAAAAADkCKAQ/original)\n如遇到有需要需做白名单处理，可通过 exclude 配置项实现，exclude 的项是 npm 依赖的包名。\n```ts\nexport default {\n  phantomDependency: {\n    exclude: ['lodash']\n  }\n}\n```\n"
        },
        {
          "title": "plugins",
          "property": [],
          "md": "plugins\n类型：\n`string[]`\n默认值：\n`[]`\n配置额外的 Umi 插件。\n数组项为指向插件的路径，可以是 npm 依赖、相对路径或绝对路径。如果是相对路径，则会从项目根目录开始找。\n示例，\n```js\nplugins: [\n  // npm 依赖\n  'umi-plugin-hello',\n  // 相对路径\n  './plugin',\n  // 绝对路径\n  `${__dirname}/plugin.js`,\n],\n```\n"
        },
        {
          "title": "polyfill",
          "property": [],
          "md": "polyfill\n类型：\n`{ imports: string[] }`\n默认值：\n`{}`\n设置按需引入的 polyfill。默认全量引入。\n比如只引入 core-js 的 stable 部分，\n```js\npolyfill: {\n  imports: ['core-js/stable'],\n}\n```\n如果对于性能有更极致的要求，可以考虑按需引入，\n```js\npolyfill: {\n  imports: ['core-js/features/promise/try', 'core-js/proposals/math-extensions'],\n}\n```\n注意：此功能默认开。配置 \n`polyfill: false`\n 或设置环境变量 \n`BABEL_POLYFILL=none`\n 关闭。\n"
        },
        {
          "title": "postcssLoader",
          "property": [],
          "md": "postcssLoader\n类型：\n`object`\n默认值：\n`{}`\n设置 \npostcss-loader 的配置项\n。\n"
        },
        {
          "title": "presets",
          "property": [],
          "md": "presets\n类型：\n`string[]`\n默认值：\n`[]`\n配置额外的 Umi 插件集。\n数组项为指向插件集的路径，可以是 npm 依赖、相对路径或绝对路径。如果是相对路径，则会从项目根目录开始找。\n示例，\n```js\npresets: [\n  // npm 依赖\n  'umi-preset-hello',\n  // 相对路径\n  './preset',\n  // 绝对路径\n  `${__dirname}/preset.js`,\n],\n```\n"
        },
        {
          "title": "proxy",
          "property": [],
          "md": "proxy\n类型：\n`object`\n默认值：\n`{}`\n配置代理功能。\n比如，\n```js\nproxy: {\n  '/api': {\n    'target': 'http://jsonplaceholder.typicode.com/',\n    'changeOrigin': true,\n    'pathRewrite': { '^/api' : '' },\n  }\n}\n```\n然后访问 \n`/api/users`\n 就能访问到 \nhttp://jsonplaceholder.typicode.com/users\n 的数据。\n注意：proxy 功能仅在 dev 时有效。\n"
        },
        {
          "title": "publicPath",
          "property": [],
          "md": "publicPath\n类型：\n`string`\n默认值：\n`/`\n配置 webpack 的 publicPath。\n"
        },
        {
          "title": "reactRouter5Compat",
          "property": [],
          "md": "reactRouter5Compat\n类型：\n`object`\n默认值：\n`false`\n启用 react-router 5 兼容模式。此模式下，路由组件的 props 会包含 location、match、history 和 params 属性，和 react-router 5 的保持一致。\n但要注意的是，\n此模式下会有额外的 re-render\n由于依赖库 history 更新，location 中依旧没有 query 属性\n"
        },
        {
          "title": "routes",
          "property": [],
          "md": "routes\n类型：\n`Route[]`\n默认值：\n`[]`\n配置路由。更多信息，请查看 \n配置路由\n"
        },
        {
          "title": "routeLoader",
          "property": [],
          "md": "routeLoader\n类型：\n`{ moduleType: 'esm' | 'cjs' }`\n默认值：\n`{ moduleType: 'esm' }`\n配置路由加载方式。moduleType 配置为 'cjs' 会用 \n`require`\n 的方式加载路由组件。\n```ts\n// moduleType: esm\n'index': React.lazy(() => import(/* webpackChunkName: \"p__index\" */'../../pages/index.tsx')),\n\n// moduleType: cjs\n'index': React.lazy(() => Promise.resolve(require('../../pages/index.tsx'))),\n```\n"
        },
        {
          "title": "run",
          "property": [],
          "md": "run\n类型：\n`{ globals: string[] }`\n默认值：\n`null`\nrun 命令的全局注入配置。添加\n`['zx/globals']`\n，在使用\n`umi run ./script.ts`\n的时候，umi会自动注入\n`import 'zx/globals';`\n，从而省略掉每个脚本都要写\n`import 'zx/globals';`\n。\n"
        },
        {
          "title": "runtimePublicPath",
          "property": [],
          "md": "runtimePublicPath\n类型：\n`object`\n默认值：\n`null`\n启用运行时 publicPath，开启后会使用 \n`window.publicPath`\n 作为资源动态加载的起始路径。\n比如，\n```js\nruntimePublicPath: {},\n```\n"
        },
        {
          "title": "scripts",
          "property": [],
          "md": "scripts\n类型：\n`string[] | Script[]`\n默认值：\n`[]`\n配置 \n`<body>`\n 中额外的 script 标签。\n比如，\n```js\nscripts: [`alert(1);`, `https://a.com/b.js`],\n```\n会生成 HTML，\n```html\n<script>\n  alert(1);\n</script>\n<script src=\"https://a.com/b.js\"></script>\n```\n如果需要额外属性，切换到对象格式，比如，\n```js\nscripts: [\n  { src: '/foo.js', defer: true },\n  { content: `alert('你好');`, charset: 'utf-8' },\n],\n```\n"
        },
        {
          "title": "sassLoader",
          "property": [],
          "md": "sassLoader\n类型：\n`object`\n默认值：\n`{}`\n配置 sass-loader ，详见 \nsass-loader > options\n"
        },
        {
          "title": "styleLoader",
          "property": [],
          "md": "styleLoader\n类型：\n`object`\n默认值：\n`false`\n启用 style loader 功能，让 CSS 内联在 JS 中，不输出额外的 CSS 文件。\n"
        },
        {
          "title": "stylusLoader",
          "property": [],
          "md": "stylusLoader\n类型：\n`object`\n默认值：\n`{}`\n配置 stylus-loader ，详见 \nstylus-loader > options\n"
        },
        {
          "title": "styles",
          "property": [],
          "md": "styles\n类型：\n`string[]`\n默认值：\n`[]`\n配置额外的 CSS。\n配置项支持内联样式和外联样式路径，后者通过是否以 https?:// 开头来判断。\n插入的样式会前置，优先级低于项目内用户编写样式。\n比如：\n```js\nstyles: [`body { color: red; }`, `https://a.com/b.css`],\n```\n会生成以下 HTML，\n```html\n<style>\n  body {\n    color: red;\n  }\n</style>\n<link rel=\"stylesheet\" href=\"https://a.com/b.css\" />\n```\n"
        },
        {
          "title": "srcTranspiler",
          "property": [],
          "md": "srcTranspiler\n类型：\n`string`\n 可选的值：\n`babel`\n, \n`swc`\n, \n`esbuild`\n默认值：\n`babel`\n配置构建时转译 js/ts 的工具。\n"
        },
        {
          "title": "srcTranspilerOptions",
          "property": [],
          "md": "srcTranspilerOptions\n类型：\n`{ swc?: SwcConfig, esbuild?: EsbuildConfig }`\n默认值：\n`undefined`\n如果你使用了 \n`swc`\n / \n`esbuild`\n 作为 \n`srcTranspiler`\n 转译器，你可以通过此选项对转译器做进一步的配置，详见 \nSwcConfig\n 、 \nEsbuildConfig\n 配置文档。\n如给 swc 添加其他的插件：\n```ts\nsrcTranspilerOptions: {\n  swc: {\n    jsc: {\n      experimental: {\n        plugins: [\n          [\n            '@swc/plugin-styled-components',\n            {\n              displayName: true,\n              ssr: true,\n            },\n          ],\n        ],\n      },\n    },\n  },\n}\n```\n"
        },
        {
          "title": "svgr",
          "property": [],
          "md": "svgr\n类型：\n`object`\n默认值：\n`{}`\nsvgr 默认开启，支持如下方式使用 React svg 组件：\n```ts\nimport SmileUrl, { ReactComponent as SvgSmile } from './smile.svg';\n```\n可配置 svgr 的行为，配置项详见 \n@svgr/core > Config\n。\n"
        },
        {
          "title": "svgo",
          "property": [],
          "md": "svgo\n类型：\n`object`\n默认值：\n`{}`\n默认使用 svgo 来优化 svg 资源，配置项详见 \nsvgo\n 。\n"
        },
        {
          "title": "targets",
          "property": [],
          "md": "targets\n类型：\n`object`\n默认值：\n`{ chrome: 80 }`\n配置需要兼容的浏览器最低版本。Umi 会根据这个自定引入 polyfill、配置 autoprefixer 和做语法转换等。\n示例，\n```js\n// 兼容 ie11\ntargets: {\n  ie: 11,\n}\n```\n"
        },
        {
          "title": "theme",
          "property": [],
          "md": "theme\n类型：\n`object`\n默认值：\n`{}`\n配置 less 变量主题。\n示例：\n```js\ntheme: { '@primary-color': '#1DA57A' }\n```\n"
        },
        {
          "title": "title",
          "property": [],
          "md": "title\n类型：\n`string`\n默认值：\n`null`\n配置全局页面 title，暂时只支持静态的 Title。\n"
        },
        {
          "title": "verifyCommit",
          "property": [],
          "md": "verifyCommit\n类型：\n`{ scope: string[]; allowEmoji: boolean }`\n默认值：\n`{ scope: ['feat', 'fix', 'docs', 'style', 'refactor', 'perf', 'test', 'workflow', 'build', 'ci', 'chore', 'types', 'wip', 'release', 'dep', 'deps', 'example', 'examples', 'merge', 'revert'] }`\n针对 verify-commit 命令的配置项。\n关于参数。\n`scope`\n 用于配置允许的 scope，不区分大小写，配置后会覆盖默认的；\n`allowEmoji`\n 开启后会允许加 EMOJI 前缀，比如 \n`💥 feat(模块): 添加了个很棒的功能`\n。\n```\nverifyCommit: {\n  scope: ['feat', 'fix'],\n  allowEmoji: true,\n}\n```\n注意：使用 \n`git revert`\n 或 \n`git merge`\n 命令以及 \n`changesets`\n 的发版 merge 格式所产生的 commit message 会默认通过校验。\n"
        },
        {
          "title": "vite",
          "property": [],
          "md": "vite\n类型：\n`object`\n默认值：\n`{}`\n开发者的配置会 merge 到 vite 的 \n默认配置\n。\n示例，\n```js\n// 更改临时文件路径到 node_modules/.bin/.vite 文件夹\nvite: {\n  cacheDir: 'node_modules/.bin/.vite',\n}\n```\n"
        },
        {
          "title": "writeToDisk",
          "property": [],
          "md": "writeToDisk\n类型：\n`boolean`\n默认值：\n`false`\n开启后会在 dev 模式下额外输出一份文件到 dist 目录，通常用于 chrome 插件、electron 应用、sketch 插件等开发场景。\n"
        }
      ]
    }
  ],
  [
    {
      "title": "命令行",
      "properties": [
        {
          "title": "build",
          "property": [],
          "md": "build\n构建项目，适用于生产环境的部署。\n```bash\n$ umi build\n```\n"
        },
        {
          "title": "config",
          "property": [],
          "md": "config\n通过命令行快速查看和修改配置。\n查看配置，可以用 \n`list`\n 或 \n`get`\n。\n```bash\n$ umi config list\n - [key: polyfill] false\n - [key: externals] { esbuild: true }\n\n$ umi config get mfsu\n - [key: externals] { esbuild: true }\n```\n修改配置，可以用 \n`set`\n 或 \n`remove`\n。\n```bash\n$ umi config set polyfill false\nset config:polyfill on /private/tmp/sorrycc-wsYpty/.umirc.ts\n\n$ umi config remove polyfill\nremove config:polyfill on /private/tmp/sorrycc-wsYpty/.umirc.ts\n```\n"
        },
        {
          "title": "dev",
          "property": [],
          "md": "dev\n启动本地开发服务器，进行项目的开发与调试。\n```bash\n$ umi dev\n        ╔═════════════════════════════════════════════════════╗\n        ║ App listening at:                                   ║\n        ║  >   Local: https://127.0.0.1:8001                  ║\nready - ║  > Network: https://192.168.1.1:8001                ║\n        ║                                                     ║\n        ║ Now you can open browser with the above addresses👆 ║\n        ╚═════════════════════════════════════════════════════╝\nevent - compiled successfully in 1051 ms (416 modules)\n```\n"
        },
        {
          "title": "generate",
          "property": [],
          "md": "generate\n用于增量生成文件或启用功能，命令行别名是 \n`g`\n。\n不加任何参数时会给交互式的生成器选择。\n```bash\n$ umi g\n# 或\n$ umi generate\n? Pick generator type › - Use arrow-keys. Return to submit.\n❯   Create Pages -- Create a umi page by page name\n    Enable Prettier -- Enable Prettier\n```\n也可以指定参数。\n```bash\n# 生成路由文件\n$ umi g page index --typescript --less\n```\n"
        },
        {
          "title": "help",
          "property": [],
          "md": "help\n查看帮助。\n```bash\n$ umi help\nUsage: umi <command> [options]\n\nCommands:\n\n    build     build app for production\n    config    umi config cli\n    dev       dev server for development\n    help      show commands help\n    setup     setup project\n    version   show umi version\n    plugin    inspect umi plugins\n    generate  generate code snippets quickly\n\nRun `umi help <command>` for more information of specific commands.\nVisit https://umijs.org/ to learn more about Umi.\n```\n也可指定命令，查看特定命令的详细帮助。\n```bash\n$ umi help build\nUsage: umi build [options]\nbuild app for production.\n\nDetails:\n    umi build\n\n    # build without compression\n    COMPRESS=none umi build\n\n    # clean and build\n    umi build --clean\n```\n"
        },
        {
          "title": "lint",
          "property": [],
          "md": "lint\n用于检查及修正代码是否符合规则。\n```bash\n$ umi lint\nUsage: umi lint\n\n 支持只校验 js、ts、tsx、jsx 类型文件： umi lint --eslint-only\n\n 支持只校验 css、less 等样式文件： umi lint --stylelint-only\n\n 支持校验 cssinjs 模式校验： umi lint --stylelint-only --cssinjs\n\n 修正代码： --fix\n\n```\n"
        },
        {
          "title": "plugin",
          "property": [],
          "md": "plugin\n插件相关操作，目前只支持 \n`list`\n 子命令。\n列出所有插件。\n```bash\n$ umi plugin list\n- @umijs/core/dist/service/servicePlugin\n- @umijs/preset-umi (from preset)\n- @umijs/preset-umi/dist/registerMethods (from preset)\n- @umijs/preset-umi/dist/features/appData/appData (from preset)\n- @umijs/preset-umi/dist/features/check/check (from preset)\n- @umijs/preset-umi/dist/features/configPlugins/configPlugins (from preset)\n- virtual: config-styles\n- virtual: config-scripts\n- virtual: config-routes\n- virtual: config-plugins\n...\n```\n"
        },
        {
          "title": "preview",
          "property": [],
          "md": "preview\n`umi preview`\n 命令会在本地启动一个静态 Web 服务器，将 dist 文件夹运行在 \nhttp://127.0.0.1:4172\n, 用于预览构建后产物, 支持 proxy、mock 等设置。\n你可以通过 \n`--port`\n 参数来配置服务的运行端口。\n```bash\n$ umi preview --port 9527\n```\n现在 \n`preview`\n 命令会将服务器运行在 \nhttp://127.0.0.1:9527\n.\n通过 \n`--host`\n 参数来指定 配置服务运行的 hostname。\n以下用户配置在 \n`preview`\n 时也会生效\nhttps\nproxy\nmock\n注意 \n`dist`\n 目录会随着配置 \n`outputPath`\n 的变更而变更。\n"
        },
        {
          "title": "run",
          "property": [],
          "md": "run\n`umi run`\n 命令可以让你像 node 运行 js 一样来运行 TypeScript 和 ESM 文件。你可以搭配 \nzx\n 来更好的使用脚本命令。\n```bash\n$ umi run ./script.ts\n```\n"
        },
        {
          "title": "setup",
          "property": [],
          "md": "setup\n初始化项目，会做临时文件的生成等操作。通常在 package.json 的 \n`scripts.postinstall`\n 里设置。\n```bash\n{\n  \"scripts\": { \"postinstall\": \"umi setup\" }\n}\n```\n"
        },
        {
          "title": "deadcode",
          "property": [],
          "md": "deadcode\n用于查找 src 目录下未被引用的文件，并在根目录输出文件。\n```bash\n$ umi deadcode\n- Preparing...\n- begin check deadCode\n- write file /examples/umi-run/DeadCodeList-{timeStamp}.txt\n- check dead code end, please be careful if you want to remove them\n```\n"
        },
        {
          "title": "mfsu",
          "property": [],
          "md": "mfsu\n`umi mfsu`\n 命令可以查看 MFSU 依赖信息、重新构建 MFSU 依赖和清除 MFSU 依赖。\n```bash title=\"获取 MFSU 命令帮忙\"\n$ umi mfsu\n```\n```bash title=\"获取 MFSU 依赖列表\"\n$ umi mfsu ls\nwarning@4.0.3\nregenerator-runtime/runtime.js@0.13.11\nreact/jsx-dev-runtime@18.1.0\nreact-intl@3.12.1\nreact-error-overlay/lib/index.js@6.0.9\nreact@18.1.0\nqiankun@2.8.4\nlodash/noop@4.17.21\nlodash/mergeWith@4.17.21\nlodash/concat@4.17.21\n...\n```\n```bash title=\"重新构建 MFSU 依赖\"\n$ umi mfsu build\ninfo  - Preparing...\ninfo  - MFSU eager strategy enabled\nwarn  - Invalidate webpack cache since mfsu cache is missing\ninfo  - [MFSU] buildDeps since cacheDependency has changed\n...\ninfo  - [plugin: @umijs/preset-umi/dist/commands/mfsu/mfsu] [MFSU][eager] build success\n```\n```bash title=\"清除 MFSU 依赖\"\n$ # 删除依赖信息列表\n$ umi mfsu remove\n$ # 删除依赖信息列表和产物文件\n$ umi mfsu remove --all\n```\n"
        },
        {
          "title": "verifyCommit",
          "property": [],
          "md": "verifyCommit\n验证 commit message 信息，通常和 \nhusky\n 搭配使用。\n比如在 \n`.husky/commit-msg`\n 做如下配置，\n```bash\n#!/bin/sh\n. \"$(dirname \"$0\")/_/husky.sh\"\n\nnpx --no-install umi verify-commit $1\n```\n"
        },
        {
          "title": "version",
          "property": [],
          "md": "version\n查看 \n`umi`\n 版本，等同于 \n`umi -v`\n。\n```bash\n$ umi version\n4.0.0\n```\n"
        }
      ]
    }
  ],
  [
    {
      "title": "API",
      "properties": [
        {
          "title": "umi",
          "property": [
            {
              "title": "createBrowserHistory",
              "md": "createBrowserHistory创建使用浏览器内置`history` 来跟踪应用的`BrowserHistory`。推荐在支持 HTML5`history` 接口的 现代 Web 浏览器中使用。类型定义如下：```tsfunction createBrowserHistory(options?: { window?: Window }) => BrowserHistory;```使用范例：```ts// create a BrowserHistoryimport { createBrowserHistory } from 'umi';const history = createBrowserHistory();// or a iframe BrowserHistoryimport { createBrowserHistory } from 'umi';const history = createBrowserHistory({  window: iframe.contentWindow,});```"
            },
            {
              "title": "createHashHistory",
              "md": "createHashHistory`createHashHistory` 返回一个`HashHistory` 实例。`window` 默认为当前`document` 的`defaultView`。`HashHistory` 与`BrowserHistory` 的主要区别在于，`HashHistory` 将当前位置存储在 URL 的哈希部分中，这意味着它在路由切换时不会发送请求到服务器。如果您将站点托管在您无法完全控制服务器上，或者在只提供同单页面的 Electron 应用程序中，推荐使用`HashHistory`。使用范例：```ts// create a HashHistoryimport { createHashHistory } from 'umi';const history = createHashHistory();```"
            },
            {
              "title": "createMemoryHistory",
              "md": "createMemoryHistory`MemoryHistory` 不会在地址栏被操作或读取。它也非常适合测试和其他的渲染环境。```tsconst history = createMemoryHistory(location)```"
            },
            {
              "title": "createSearchParams",
              "md": "createSearchParams包装`new URLSearchParams(init)` 的工具函数，支持使用数组和对象创建```tsimport { createSearchParams } from 'umi';// 假设路径 http://a.com?foo=1&bar=2createSearchParams(location.search);createSearchParams(\"foo=1&bar=2\");createSearchParams(\"?foo=1&bar=2\");// 键值对对象createSearchParams({ foo: 'bar', qux: 'qoo'}).toString()// foo=bar&qux=qoo// 键值元组数组createSearchParams([[\"foo\", \"1\"], [\"bar\", \"2\"]]).toString()// foo=1&bar=2```URLSearchParams 文档"
            },
            {
              "title": "generatePath",
              "md": "generatePath使用给定的带参数的 path 和对应的 params 生成实际要访问的路由。```tsimport { generatePath } from 'umi';generatePath(\"/users/:id\", { id: \"42\" }); // \"/users/42\"generatePath(\"/files/:type/*\", {  type: \"img\",  \"*\": \"cat.jpg\",}); // \"/files/img/cat.jpg\"```"
            },
            {
              "title": "Helmet",
              "md": "Helmet即react-helmet-async 提供的 Helmet 组件，用于在页面中动态配置`head` 中的标签，例如`title`。注意：为了确保 SSR 时 Helmet 仍能正常工作，请务必使用 Umi 提供的 Helmet 而不是单独安装 react-helmet```tsximport { Helmet } from 'umi';export default function Page() {  return (    <Helmet>      <title>Hello World</title>    </Helmet>  );}```"
            },
            {
              "title": "history",
              "md": "history和 history 相关的操作，用于获取当前路由信息、执行路由跳转、监听路由变更。```ts// 建议组件或 hooks 里用 useLocation 取import { useLocation } from 'umi';export default function Page() {  let location = useLocation();  return (    <div>     { location.pathname }     { location.search }     { location.hash }    </div>  );}```如果在 React 组件和 Hooks 之外获取当前路由信息。```ts// location 对象，包含 pathname、search 和 hashwindow.location.pathname;window.location.search;window.location.hash;```命令式路由跳转。```tsimport { history } from 'umi';// 跳转到指定路由history.push('/list');// 带参数跳转到指定路由history.push('/list?a=b&c=d#anchor', state);history.push({    pathname: '/list',    search: '?a=b&c=d',    hash: 'anchor',  },  {    some: 'state-data',  });// 跳转当前路径，并刷新 statehistory.push({}, state)// 跳转到上一个路由history.back();history.go(-1);```:::info{title=🚨}注意：history.push 和 history.replace 需要使用`state` 需将`state` 作为这两个 API 的第二个参数传递:::路由监听。```tsimport { history } from 'umi';const unlisten = history.listen(({ location, action }) => {  console.log(location.pathname);});unlisten();```"
            },
            {
              "title": "Link",
              "md": "Link`<Link>` 是 React 组件，是带路由跳转功能的`<a>` 元素。类型定义如下：```tsdeclare function Link(props: {  prefetch?: boolean;  to: string | Partial<{ pathname: string; search: string; hash: string }>;  replace?: boolean;  state?: any;  reloadDocument?: boolean;}): React.ReactElement;```示例：```tsximport { Link } from 'umi';function IndexPage({ user }) {  return <Link to={user.id}>{user.name}</Link>;}````<Link to>` 支持相对路径跳转；`<Link reloadDocument>` 不做路由跳转，等同于`<a href>` 的跳转行为。若开启了`prefetch` 则当用户将鼠标放到该组件上方时，Umi 就会自动开始进行跳转路由的组件 js 文件和数据预加载。"
            },
            {
              "title": "matchPath",
              "md": "matchPath`matchPath` 可以将给定的路径以及一个已知的路由格式进行匹配，并且返回匹配结果。类型定义如下：```tsdeclare function matchPath<ParamKey extends string = string>(  pattern: PathPattern | string,  pathname: string): PathMatch<ParamKey> | null;interface PathMatch<ParamKey extends string = string> {  params: Params<ParamKey>;  pathname: string;  pattern: PathPattern;}interface PathPattern {  path: string;  caseSensitive?: boolean;  end?: boolean;}```示例：```tsimport { matchPath } from 'umi';const match = matchPath(  { path: \"/users/:id\" },  \"/users/123\",);// {//   \"params\": { \"id\": \"123\" },//   \"pathname\": \"/users/123\",//   \"pathnameBase\": \"/users/123\",//   \"pattern\": { \"path\": \"/users/:id\" }// }```"
            },
            {
              "title": "matchRoutes",
              "md": "matchRoutes`matchRoutes` 可以将给定的路径以及多个可能的路由选择进行匹配，并且返回匹配结果。类型定义如下：```tsdeclare function matchRoutes(  routes: RouteObject[],  location: Partial<Location> | string,  basename?: string): RouteMatch[] | null;interface RouteMatch<ParamKey extends string = string> {  params: Params<ParamKey>;  pathname: string;  route: RouteObject;}```示例：```tsimport { matchRoutes } from 'umi';const match = matchRoutes(  [    {      path: \"/users/:id\",    },    {      path: \"/users/:id/posts/:postId\",    },  ],  \"/users/123/posts/456\",);// [//  {//    \"params\": {//      \"id\": \"123\",//       \"postId\": \"456\"//     },//     \"pathname\": \"/users/123/posts/456\",//     \"pathnameBase\": \"/users/123/posts/456\",//     \"route\": {//       \"path\": \"/users/:id/posts/:postId\"//     }//   }// ]```"
            },
            {
              "title": "NavLink",
              "md": "NavLink`<NavLink>` 是`<Link>` 的特殊形态，他知道当前是否为路由激活状态。通常在导航菜单、面包屑、Tabs 中会使用，用于显示当前的选中状态。类型定义如下：```tsdeclare function NavLink(props: LinkProps & {  caseSensitive?: boolean;  children?: React.ReactNode | ((props: { isActive: boolean }) => React.ReactNode);  className?: string | ((props: { isActive: boolean }) => string | undefined);  end?: boolean;  style?: React.CSSProperties | ((props: { isActive: boolean }) => string | React.CSSProperties);}): React.ReactElement;```下方示例分别用了 style、className 和 children 来渲染 active 状态。```tsimport { NavLink } from 'umi';function Navs() {  return <ul>    <li><NavLink to=\"message\" style={({ isActive }) => isActive ? { color: 'red' } : undefined}>Messages</NavLink></li>    <li><NavLink to=\"tasks\" className={({ isActive }) => isActive ? 'active' : undefined}>Tasks</NavLink></li>    <li><NavLink to=\"blog\">{({ isActive }) => <span className={isActive ? 'active' : undefined}>Blog</span>}</NavLink></li>  </ul>;}```"
            },
            {
              "title": "Outlet",
              "md": "Outlet`<Outlet>` 用于渲染父路由中渲染子路由。如果父路由被严格匹配，会渲染子路由中的 index 路由（如有）。类型定义如下：```tsinterface OutletProps {  context?: unknown;}declare function Outlet(  props: OutletProps): React.ReactElement | null;```示例：```tsimport { Outlet } from 'umi';function Dashboard() {  return (    <div>      <h1>Dashboard</h1>      <Outlet />    </div>  );}function DashboardWithContext() {  return (    <div>      <h1>Dashboard</h1>      <Outlet context={{ prop: 'a' }}/>    </div>  );}````Outlet` 组件的`context` 可以使用 API`useOutletContext` 在子组件中获取。"
            },
            {
              "title": "resolvePath",
              "md": "resolvePath用于在客户端解析前端路由跳转路径。类型定义如下：```tsdeclare function resolvePath(  to: Partial<Location> | string,  fromPathname?: string): {  pathname: string;  search: string;  hash: string;};```示例：```ts// 同级相对跳转，返回 { pathname: '/parent/child', search: '', hash: '' }resolvePath('child', '/parent');resolvePath('./child', '/parent');resolvePath('', '/parent/child');resolvePath('.', '/parent/child');// 祖先层级相对跳转，返回 { pathname: '/parent/sibling', search: '', hash: '' }resolvePath('../sibling', '/parent/child');resolvePath('../../parent/sibling', '/other/child');// 绝对跳转，返回 { pathname: '/target', search: '', hash: '' }resolvePath('/target', '/parent');resolvePath('/target', '/parent/child');// 携带 search 和 hash 跳转，返回 { pathname: '/params', search: '?a=b', hash: '#c' }resolvePath('/params?a=b#c', '/prev');```"
            },
            {
              "title": "terminal",
              "md": "terminal`terminal` 用于在开发阶段在浏览器向 node 终端输出日志的工具。示例：```tsimport {terminal} from 'umi';// 下面三条命令会在 umi 启动终端上打出用不同颜色代表的日志terminal.log('i am log level');terminal.warn('i am warn level');terminal.error('i am error level');```注意`terminal` 只在环境变量`NODE_ENV` 非`production` 时生效；在 Umi 的构建产物中对应的日志调用函数不会有任何作用，所以可以不必删除调用`terminal` 的代码。"
            },
            {
              "title": "useAppData",
              "md": "useAppData`useAppData` 返回全局的应用数据。类型定义如下：```tsdeclare function useAppData(): {  routes: Record<id, Route>;  routeComponents: Record<id, Promise<React.ReactComponent>>;  clientRoutes: ClientRoute[];  pluginManager: any;  rootElement: string;  basename: string;  clientLoaderData: { [routeKey: string]: any };  preloadRoute: (to: string) => void;};```注意：此处 API 可能还会调整。"
            },
            {
              "title": "useLocation",
              "md": "useLocation`useLocation` 返回当前 location 对象。类型定义如下：```tsdeclare function useLocation(): {  pathname: string;  search: string;  state: unknown;  key: Key;};```一个场景是在 location change 时做一些 side effect 操作，比如 page view 统计。```tsimport { useLocation } from 'umi';function App() {  const location = useLocation();  React.useEffect(() => {    ga('send', 'pageview');  }, [location]);  // ...}```"
            },
            {
              "title": "useMatch",
              "md": "useMatch`useMatch` 返回传入 path 的匹配信息；如果匹配失败将返回`null`类型定义如下：```tsdeclare function useMatch(pattern: {  path: string;  caseSensitive?: boolean;  end?: boolean;} | string): {  params: Record<string, string>;  pathname: string;  pattern: {    path: string;    caseSensitive?: boolean;    end?: boolean;  };};```示例：```tsximport { useMatch } from 'umi';// when url = '/events/12'const match = useMatch('/events/:eventId');console.log(match?.pathname, match?.params.eventId);// '/events/12 12'```"
            },
            {
              "title": "useNavigate",
              "md": "useNavigate`useNavigate` 钩子函数返回一个可以控制跳转的函数；比如可以用在提交完表单后跳转到其他页面。```tsdeclare function useNavigate(): NavigateFunction;interface NavigateFunction {  (    to: To,    options?: { replace?: boolean; state?: any }  ): void;  (delta: number): void;}```示例：跳转路径```tsimport { useNavigate } from 'umi';let navigate = useNavigate();navigate(\"../success\", { replace: true });```返回上一页```tsimport { useNavigate } from 'umi';let navigate = useNavigate();navigate(-1);```"
            },
            {
              "title": "useOutlet",
              "md": "useOutlet`useOutlet` 返回当前匹配的子路由元素，`<Outlet>` 内部使用的就是此 hook 。类型定义如下：```tsdeclare function useOutlet(): React.ReactElement | null;```示例：```tsimport { useOutlet } from 'umi';const Layout = ()=>{  const outlet = useOutlet()  return <div className=\"fancyLayout\">    {outlet}  </div>}```"
            },
            {
              "title": "useOutletContext",
              "md": "useOutletContext`useOutletContext` 用于返回`Outlet` 组件上挂载的`context` 。类型定义如下：```tsdeclare function useOutletContext<Context = unknown>(): Context;```示例：```tsimport { useOutletContext, Outlet } from 'umi';const Layout = () => {  return <div className=\"fancyLayout\">    <Outlet context={{ prop: 'from Layout'}} />  </div>}const SomeRouteComponentUnderLayout = () => {  const layoutContext = useOutletContext();  return JSON.stringify(layoutContext)   // {\"prop\":\"from Layout\"}}```"
            },
            {
              "title": "useParams",
              "md": "useParams`useParams` 钩子函数返回动态路由的匹配参数键值对对象；子路由中会集成父路由的动态参数。类型定义如下：```tsdeclare function useParams<  K extends string = string>(): Readonly<Params<K>>;```示例：```tsimport { useParams } from 'umi';// 假设有路由配置  user/:uId/repo/:rId// 当前路径       user/abc/repo/defconst params = useParams()/* params{ uId: 'abc', rId: 'def'}*/```"
            },
            {
              "title": "useResolvedPath",
              "md": "useResolvedPath`useResolvedPath` 根据当前路径将目标地址解析出完整的路由信息。类型定义如下：```tsdeclare function useResolvedPath(to: To): Path;```示例：```tsimport { useResolvedPath } from 'umi';const path = useResolvedPath('docs')/* path{ pathname: '/a/new/page/docs', search: '', hash: '' }*/```"
            },
            {
              "title": "useRouteData",
              "md": "useRouteData`useRouteData` 返回当前匹配路由的数据的钩子函数。类型定义如下：```tsdeclare function useRouteData(): {  route: Route;};```注意：此处 API 可能还会调整。示例：```tsimport { useRouteData } from 'umi';const route = useRouteData();/* route{  route: {    path: 'a/page',    id: 'a/page/index',    parentId: '@@/global-layout',    file: 'a/page/index.tsx'  }}*/```"
            },
            {
              "title": "useRoutes",
              "md": "useRoutes`useRoutes` 渲染路由的钩子函数，传入路由配置和可选参数`location`, 即可得到渲染结果；如果没有匹配的路由，结果为`null`。类型定义如下：```tsdeclare function useRoutes(  routes: RouteObject[],  location?: Partial<Location> | string;): React.ReactElement | null;```示例：```tsimport * as React from \"react\";import { useRoutes } from \"umi\";function App() {  let element = useRoutes([    {      path: \"/\",      element: <Dashboard />,      children: [        {          path: \"messages\",          element: <DashboardMessages />,        },        { path: \"tasks\", element: <DashboardTasks /> },      ],    },    { path: \"team\", element: <AboutPage /> },  ]);  return element;}```"
            },
            {
              "title": "useRouteProps",
              "md": "useRouteProps读取当前路由在路由配置里的 props 属性，你可以用此 hook 来获取路由配置中的额外信息。```ts// .umirc.tsroutes: [  {    path: '/',    custom_key: '1',  }]``````tsimport { useRouteProps } from 'umi'export default function Page() {  const routeProps = useRouteProps()  // use `routeProps.custom_key`} ```注：同样适用于约定式路由。"
            },
            {
              "title": "useSelectedRoutes",
              "md": "useSelectedRoutes用于读取当前路径命中的所有路由信息。比如在`layout` 布局中可以获取到当前命中的所有子路由信息，同时可以获取到在`routes` 配置中的参数，这格外有用。实例：```tsx// layouts/index.tsximport { useSelectedRoutes } from 'umi'export default function Layout() {  const routes = useSelectedRoutes()  const lastRoute = routes.at(-1)  if (lastRoute?.pathname === '/some/path') {    return <div>1 : <Outlet /></div>  }  if (lastRoute?.extraProp) {    return <div>2 : <Outlet /></div>  }  return <Outlet />}```"
            },
            {
              "title": "useSearchParams",
              "md": "useSearchParams`useSearchParams` 用于读取和修改当前 URL 的 query string。类似 React 的`useState`，其返回包含两个值的数组，当前 URL 的 search 参数和用于更新 search 参数的函数。类型定义如下：```tsdeclare function useSearchParams(defaultInit?: URLSearchParamsInit): [  URLSearchParams,  (    nextInit?: URLSearchParamsInit,    navigateOpts?: : { replace?: boolean; state?: any }  ) => void];type URLSearchParamsInit =  | string  | ParamKeyValuePair[]  | Record<string, string | string[]>  | URLSearchParams;```示例：```tsimport React from 'react';import { useSearchParams } from 'umi';function App() {  let [searchParams, setSearchParams] = useSearchParams();  function handleSubmit(event) {    event.preventDefault();    setSearchParams(serializeFormQuery(event.target));  }  return <form onSubmit={handleSubmit}>{/* ... */}</form>;}```"
            },
            {
              "title": "withRouter",
              "md": "withRouter`withRouter` 参考react-router faq 实现的版本, 仅实现了部分能力, 请参考类型定义按需使用, 建议迁移到 React Hook API。类型定义如下:```tsexport interface RouteComponentProps<T = ReturnType<typeof useParams>> {  history: {    back: () => void;    goBack: () => void;    location: ReturnType<typeof useLocation>;    push: (url: string, state?: any) => void;  };  location: ReturnType<typeof useLocation>;  match: {    params: T;  };  params: T;  navigate: ReturnType<typeof useNavigate>;}```示例：```tsximport React from 'react';import { withRouter } from 'umi';class HelloWorld extends React.Component<any> {  render() {    return (      <div>        Hello World {this.props.location.pathname}        <h2>params: {JSON.stringify(this.props.match.params)}</h2>        <button          onClick={() => {            this.props.history.push('/users');          }}        >          To Users        </button>      </div>    );  }}export default withRouter(HelloWorld);```"
            }
          ],
          "md": "umi\n"
        }
      ]
    }
  ]
]